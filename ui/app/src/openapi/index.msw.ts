/**
 * Generated by orval v6.12.1 🍺
 * Do not edit manually.
 * Chaos Mesh Dashboard API
 * Swagger for Chaos Mesh Dashboard. If you encounter any problems with API, please click on the issues link below to report.
 * OpenAPI spec version: 2.5
 */
import { faker } from '@faker-js/faker'
import { rest } from 'msw'

export const getDeleteArchivesMock = () => ({ status: faker.random.word() })

export const getGetArchivesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw7a00005kt6g9z9h0d6: faker.random.word(),
      },
      labels: {
        cmauzgw7a00015kt6adbw1fry: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesSchedulesMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw7i00025kt6g2gdhttb: faker.random.word(),
      },
      labels: {
        cmauzgw7i00035kt64nsq8u08: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getDeleteArchivesWorkflowsMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getDeleteArchivesWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetArchivesWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw7n00045kt6bm4ocg4i: faker.random.word(),
      },
      labels: {
        cmauzgw7n00055kt6cii4eplf: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  uid: faker.random.word(),
})

export const getGetCommonAnnotationsMock = () => ({
  cmauzgw7o00065kt6ggie6fcl: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word(),
  ),
})

export const getGetCommonChaosAvailableNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonConfigMock = () => ({
  cluster_mode: faker.datatype.boolean(),
  dns_server_create: faker.datatype.boolean(),
  enableFilterNamespace: faker.datatype.boolean(),
  gcp_security_mode: faker.datatype.boolean(),
  listen_host: faker.random.word(),
  listen_port: faker.datatype.number({ min: undefined, max: undefined }),
  root_path: faker.random.word(),
  security_mode: faker.datatype.boolean(),
  target_namespace: faker.random.word(),
  version: faker.random.word(),
})

export const getGetCommonKindsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonLabelsMock = () => ({
  cmauzgw7s00075kt6etac2zo4: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word(),
  ),
})

export const getGetCommonNamespacesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, () => faker.random.word())

export const getGetCommonPhysicalmachineAnnotationsMock = () => ({
  cmauzgw7u00085kt65ry6acp3: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word(),
  ),
})

export const getGetCommonPhysicalmachineLabelsMock = () => ({
  cmauzgw7v00095kt6a9f6619x: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => faker.random.word(),
  ),
})

export const getPostCommonPhysicalmachinesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    address: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
  }))

export const getPostCommonPodsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ip: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    state: faker.random.word(),
  }))

export const getGetCommonRbacConfigMock = () => ({
  cmauzgw7y000a5kt6er2bbieo: faker.random.word(),
})

export const getGetEventsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getGetEventsIdMock = () => ({
  created_at: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  message: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  object_id: faker.random.word(),
  reason: faker.random.word(),
  type: faker.random.word(),
})

export const getGetEventsWorkflowUidMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    kind: faker.random.word(),
    message: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    object_id: faker.random.word(),
    reason: faker.random.word(),
    type: faker.random.word(),
  }))

export const getDeleteExperimentsMock = () => ({ status: faker.random.word() })

export const getGetExperimentsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    failed_message: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostExperimentsMock = () => ({})

export const getDeleteExperimentsUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsUidMock = () => ({
  created_at: faker.random.word(),
  failed_message: faker.random.word(),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw82000b5kt6hwsfg3vj: faker.random.word(),
      },
      labels: {
        cmauzgw82000c5kt66omad4to: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutExperimentsPauseUidMock = () => ({ status: faker.random.word() })

export const getPutExperimentsStartUidMock = () => ({ status: faker.random.word() })

export const getGetExperimentsStateMock = () => ({
  deleting: faker.datatype.number({ min: undefined, max: undefined }),
  finished: faker.datatype.number({ min: undefined, max: undefined }),
  injecting: faker.datatype.number({ min: undefined, max: undefined }),
  paused: faker.datatype.number({ min: undefined, max: undefined }),
  running: faker.datatype.number({ min: undefined, max: undefined }),
})

export const getDeleteSchedulesMock = () => ({ status: faker.random.word() })

export const getGetSchedulesMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    kind: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostSchedulesMock = () => ({
  annotations: {
    cmauzgw86000d5kt60iqtci18: faker.random.word(),
  },
  apiVersion: faker.random.word(),
  creationTimestamp: faker.random.word(),
  deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
  deletionTimestamp: faker.random.word(),
  finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word(),
  ),
  generateName: faker.random.word(),
  generation: faker.datatype.number({ min: undefined, max: undefined }),
  kind: faker.random.word(),
  labels: {
    cmauzgw86000e5kt69pok27am: faker.random.word(),
  },
  managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    fieldsType: faker.random.word(),
    fieldsV1: {},
    manager: faker.random.word(),
    operation: faker.random.word(),
    subresource: faker.random.word(),
    time: faker.random.word(),
  })),
  name: faker.random.word(),
  namespace: faker.random.word(),
  ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    apiVersion: faker.random.word(),
    blockOwnerDeletion: faker.datatype.boolean(),
    controller: faker.datatype.boolean(),
    kind: faker.random.word(),
    name: faker.random.word(),
    uid: faker.random.word(),
  })),
  resourceVersion: faker.random.word(),
  selfLink: faker.random.word(),
  spec: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw86000f5kt6c9y2fmv7: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw86000g5kt6cls95k1a: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw86000h5kt6fku26jor: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw86000i5kt68kwl7p32: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw86000j5kt63xyf15a0: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw86000k5kt62w9qgyn7: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw86000l5kt6e6ej3z7z: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw86000m5kt6agblh97s: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw86000n5kt6a2i908f1: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw86000o5kt6d298efey: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          cmauzgw86000p5kt6hva602kl: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          cmauzgw86000q5kt6fi1sh1yg: faker.random.word(),
        },
      },
      request_headers: {
        cmauzgw86000r5kt66kn1bg3g: faker.random.word(),
      },
      response_headers: {
        cmauzgw86000s5kt6dr70d5ap: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          cmauzgw86000t5kt62xup166e: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw86000u5kt6ha4e90d6: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw86000v5kt670o07ki3: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw86000w5kt6gz082tw3: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw86000x5kt6bpwzdrpx: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw86000y5kt67022efsm: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw87000z5kt63hbt3i2n: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8700105kt60x8ihjjo: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8700115kt67uycdvbs: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8700125kt65fu765y5: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      returnValue: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8700135kt66v6q1mr9: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8700145kt6ehxreqy1: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8700155kt62hxb4aoe: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8700165kt6cqegdidv: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8700175kt62wthdslm: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8700185kt60gwh8csf: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8700195kt6hg6z24f4: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw87001a5kt62lgveax4: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw87001b5kt6giyeeht8: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw87001c5kt6h1kd0cx3: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      rate: { rate: faker.random.word() },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw87001d5kt6h221hhvr: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw87001e5kt6fvfm3vle: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw87001f5kt65aon4gdz: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw87001g5kt673kwh04u: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw87001h5kt6apm8ht5j: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            cmauzgw87001i5kt68ww2hxk2: faker.random.word(),
          },
          expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            }),
          ),
          fieldSelectors: {
            cmauzgw87001j5kt62zrdhcof: faker.random.word(),
          },
          labelSelectors: {
            cmauzgw87001k5kt6d89g16nh: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          nodeSelectors: {
            cmauzgw87001l5kt6ffz054kj: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word(),
          ),
          pods: {
            cmauzgw87001m5kt6cdv4gfnf: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw88001n5kt6a78a6viw: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw88001o5kt650oh3m7a: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw88001p5kt6b3b30egu: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        physicalMachines: {
          cmauzgw88001q5kt66ebv3fel: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw88001r5kt6fsxue3l1: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw88001s5kt68ei80r5t: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw88001t5kt6bbbv0n4m: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw88001u5kt605uw5465: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw88001v5kt6a82wd2yr: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw88001w5kt67apb3g1b: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw88001x5kt60vpj8jhz: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw88001y5kt64zui3f9y: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw88001z5kt6797c6fwo: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8800205kt68ve0desc: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8800215kt66el1g0p5: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8800225kt66tm2716e: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8800235kt628u540n7: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8800245kt61xr6b3ti: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8800255kt65psq5fj5: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
    workflow: {
      entry: faker.random.word(),
      templates: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        abortWithStatusCheck: faker.datatype.boolean(),
        awsChaos: {
          action: faker.random.word(),
          awsRegion: faker.random.word(),
          deviceName: faker.random.word(),
          duration: faker.random.word(),
          ec2Instance: faker.random.word(),
          endpoint: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          volumeID: faker.random.word(),
        },
        azureChaos: {
          action: faker.random.word(),
          diskName: faker.random.word(),
          duration: faker.random.word(),
          lun: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          resourceGroupName: faker.random.word(),
          secretName: faker.random.word(),
          subscriptionID: faker.random.word(),
          vmName: faker.random.word(),
        },
        blockChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw8800265kt68kl51byy: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8800275kt6dvwgfvsa: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8800285kt63s6va58i: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8800295kt61lod14ea: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw88002a5kt6d2xpbr31: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumeName: faker.random.word(),
        },
        children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({ expression: faker.random.word(), target: faker.random.word() }),
        ),
        deadline: faker.random.word(),
        dnsChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw88002b5kt61mcg303d: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw88002c5kt61yvu8hu1: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw88002d5kt63wdy5htm: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw88002e5kt61p6vezve: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw88002f5kt64r0c3304: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        gcpChaos: {
          action: faker.random.word(),
          deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          instance: faker.random.word(),
          project: faker.random.word(),
          remoteCluster: faker.random.word(),
          secretName: faker.random.word(),
          zone: faker.random.word(),
        },
        httpChaos: {
          abort: faker.datatype.boolean(),
          code: faker.datatype.number({ min: undefined, max: undefined }),
          delay: faker.random.word(),
          duration: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          patch: {
            body: { type: faker.random.word(), value: faker.random.word() },
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            ),
            queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            ),
          },
          path: faker.random.word(),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          replace: {
            body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined }),
            ),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            headers: {
              cmauzgw88002g5kt67ph899g8: faker.random.word(),
            },
            method: faker.random.word(),
            path: faker.random.word(),
            queries: {
              cmauzgw88002h5kt69d6f1kst: faker.random.word(),
            },
          },
          request_headers: {
            cmauzgw88002i5kt66y1q0iqh: faker.random.word(),
          },
          response_headers: {
            cmauzgw88002j5kt6d711h66j: faker.random.word(),
          },
          selector: {
            annotationSelectors: {
              cmauzgw88002k5kt60zjag1z3: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw88002l5kt69c7h7faj: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw88002m5kt652446d6c: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw88002n5kt66o6vd79q: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw88002o5kt6ar274kf8: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          target: faker.random.word(),
          tls: {
            caName: faker.random.word(),
            certName: faker.random.word(),
            keyName: faker.random.word(),
            secretName: faker.random.word(),
            secretNamespace: faker.random.word(),
          },
          value: faker.random.word(),
        },
        ioChaos: {
          action: faker.random.word(),
          attr: {
            atime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            blocks: faker.datatype.number({ min: undefined, max: undefined }),
            ctime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            gid: faker.datatype.number({ min: undefined, max: undefined }),
            ino: faker.datatype.number({ min: undefined, max: undefined }),
            kind: faker.random.word(),
            mtime: {
              nsec: faker.datatype.number({ min: undefined, max: undefined }),
              sec: faker.datatype.number({ min: undefined, max: undefined }),
            },
            nlink: faker.datatype.number({ min: undefined, max: undefined }),
            perm: faker.datatype.number({ min: undefined, max: undefined }),
            rdev: faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.datatype.number({ min: undefined, max: undefined }),
            uid: faker.datatype.number({ min: undefined, max: undefined }),
          },
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          delay: faker.random.word(),
          duration: faker.random.word(),
          errno: faker.datatype.number({ min: undefined, max: undefined }),
          methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          mistake: {
            filling: faker.random.word(),
            maxLength: faker.datatype.number({ min: undefined, max: undefined }),
            maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          path: faker.random.word(),
          percent: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw88002p5kt6f5ap7gs4: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw89002q5kt69vv5ednh: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw89002r5kt66v2obx6p: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw89002s5kt653gc33q0: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw89002t5kt66qxf956l: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
          volumePath: faker.random.word(),
        },
        jvmChaos: {
          action: faker.random.word(),
          class: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
          database: faker.random.word(),
          duration: faker.random.word(),
          exception: faker.random.word(),
          latency: faker.datatype.number({ min: undefined, max: undefined }),
          memType: faker.random.word(),
          method: faker.random.word(),
          mode: faker.random.word(),
          mysqlConnectorVersion: faker.random.word(),
          name: faker.random.word(),
          pid: faker.datatype.number({ min: undefined, max: undefined }),
          port: faker.datatype.number({ min: undefined, max: undefined }),
          remoteCluster: faker.random.word(),
          returnValue: faker.random.word(),
          ruleData: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw89002u5kt62p03a64y: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw89002v5kt6fme5geva: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw89002w5kt6dcfj9oyh: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw89002x5kt678qp7j4l: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw89002y5kt6hsp8a0sk: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          sqlType: faker.random.word(),
          table: faker.random.word(),
          value: faker.random.word(),
        },
        kernelChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          failKernRequest: {
            callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              funcname: faker.random.word(),
              parameters: faker.random.word(),
              predicate: faker.random.word(),
            })),
            failtype: faker.datatype.number({ min: undefined, max: undefined }),
            headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            probability: faker.datatype.number({ min: undefined, max: undefined }),
            times: faker.datatype.number({ min: undefined, max: undefined }),
          },
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw89002z5kt6g6eq4on5: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8900305kt6fh5m0o6y: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8900315kt649gdf8zu: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8900325kt61xpqdrr9: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw8900335kt67nkmc9mc: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        name: faker.random.word(),
        networkChaos: {
          action: faker.random.word(),
          bandwidth: {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
          delay: {
            correlation: faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            reorder: {
              correlation: faker.random.word(),
              gap: faker.datatype.number({ min: undefined, max: undefined }),
              reorder: faker.random.word(),
            },
          },
          device: faker.random.word(),
          direction: faker.random.word(),
          duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
          duration: faker.random.word(),
          externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          loss: { correlation: faker.random.word(), loss: faker.random.word() },
          mode: faker.random.word(),
          rate: { rate: faker.random.word() },
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw8900345kt63id836gm: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8900355kt60bpl6ri2: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8900365kt6evo4g5uk: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8900375kt66ps60mty: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw8900385kt6d2yv194m: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          target: {
            mode: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8900395kt6hi0gg8nu: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw89003a5kt6490ld1q3: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw89003b5kt6gc0u2dne: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw89003c5kt683o70pn8: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw89003d5kt6a6hagvao: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          targetDevice: faker.random.word(),
          value: faker.random.word(),
        },
        physicalmachineChaos: {
          action: faker.random.word(),
          address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          clock: {
            'clock-ids-slice': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            'time-offset': faker.random.word(),
          },
          'disk-fill': {
            'fill-by-fallocate': faker.datatype.boolean(),
            path: faker.random.word(),
            size: faker.random.word(),
          },
          'disk-read-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          'disk-write-payload': {
            path: faker.random.word(),
            'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
            size: faker.random.word(),
          },
          duration: faker.random.word(),
          'file-append': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            data: faker.random.word(),
            'file-name': faker.random.word(),
          },
          'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
          'file-modify': {
            'file-name': faker.random.word(),
            privilege: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
          'file-replace': {
            'dest-string': faker.random.word(),
            'file-name': faker.random.word(),
            line: faker.datatype.number({ min: undefined, max: undefined }),
            'origin-string': faker.random.word(),
          },
          'http-abort': {
            code: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined }),
            ),
            target: faker.random.word(),
          },
          'http-config': { file_path: faker.random.word() },
          'http-delay': {
            code: faker.random.word(),
            delay: faker.random.word(),
            method: faker.random.word(),
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.datatype.number({ min: undefined, max: undefined }),
            ),
            target: faker.random.word(),
          },
          'http-request': {
            count: faker.datatype.number({ min: undefined, max: undefined }),
            'enable-conn-pool': faker.datatype.boolean(),
            url: faker.random.word(),
          },
          'jvm-exception': {
            class: faker.random.word(),
            exception: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-gc': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-latency': {
            class: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'jvm-mysql': {
            database: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            mysqlConnectorVersion: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            sqlType: faker.random.word(),
            table: faker.random.word(),
          },
          'jvm-return': {
            class: faker.random.word(),
            method: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            value: faker.random.word(),
          },
          'jvm-rule-data': {
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            'rule-data': faker.random.word(),
          },
          'jvm-stress': {
            'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
            'mem-type': faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'kafka-fill': {
            host: faker.random.word(),
            maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            reloadCommand: faker.random.word(),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-flood': {
            host: faker.random.word(),
            messageSize: faker.datatype.number({ min: undefined, max: undefined }),
            password: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            threads: faker.datatype.number({ min: undefined, max: undefined }),
            topic: faker.random.word(),
            username: faker.random.word(),
          },
          'kafka-io': {
            configFile: faker.random.word(),
            nonReadable: faker.datatype.boolean(),
            nonWritable: faker.datatype.boolean(),
            topic: faker.random.word(),
          },
          mode: faker.random.word(),
          'network-bandwidth': {
            buffer: faker.datatype.number({ min: undefined, max: undefined }),
            device: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            limit: faker.datatype.number({ min: undefined, max: undefined }),
            minburst: faker.datatype.number({ min: undefined, max: undefined }),
            peakrate: faker.datatype.number({ min: undefined, max: undefined }),
            rate: faker.random.word(),
          },
          'network-corrupt': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-delay': {
            'accept-tcp-flags': faker.random.word(),
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            jitter: faker.random.word(),
            latency: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-dns': {
            'dns-domain-name': faker.random.word(),
            'dns-ip': faker.random.word(),
            'dns-server': faker.random.word(),
          },
          'network-down': { device: faker.random.word(), duration: faker.random.word() },
          'network-duplicate': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-flood': {
            duration: faker.random.word(),
            'ip-address': faker.random.word(),
            parallel: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.random.word(),
            rate: faker.random.word(),
          },
          'network-loss': {
            correlation: faker.random.word(),
            device: faker.random.word(),
            'egress-port': faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
            percent: faker.random.word(),
            'source-port': faker.random.word(),
          },
          'network-partition': {
            'accept-tcp-flags': faker.random.word(),
            device: faker.random.word(),
            direction: faker.random.word(),
            hostname: faker.random.word(),
            'ip-address': faker.random.word(),
            'ip-protocol': faker.random.word(),
          },
          process: {
            process: faker.random.word(),
            recoverCmd: faker.random.word(),
            signal: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-cacheLimit': {
            addr: faker.random.word(),
            cacheSize: faker.random.word(),
            password: faker.random.word(),
            percent: faker.random.word(),
          },
          'redis-expiration': {
            addr: faker.random.word(),
            expiration: faker.random.word(),
            key: faker.random.word(),
            option: faker.random.word(),
            password: faker.random.word(),
          },
          'redis-penetration': {
            addr: faker.random.word(),
            password: faker.random.word(),
            requestNum: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'redis-restart': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          'redis-stop': {
            addr: faker.random.word(),
            conf: faker.random.word(),
            flushConfig: faker.datatype.boolean(),
            password: faker.random.word(),
            redisPath: faker.datatype.boolean(),
          },
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw89003e5kt660fubof1: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw89003f5kt66fllcpvg: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw89003g5kt60aywhgo6: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            physicalMachines: {
              cmauzgw89003h5kt60455fvnx: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          'stress-cpu': {
            load: faker.datatype.number({ min: undefined, max: undefined }),
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            workers: faker.datatype.number({ min: undefined, max: undefined }),
          },
          'stress-mem': {
            options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            size: faker.random.word(),
          },
          user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
          value: faker.random.word(),
          vm: { 'vm-name': faker.random.word() },
        },
        podChaos: {
          action: faker.random.word(),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw8a003i5kt68chzcttf: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8a003j5kt67xcvd5ea: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8a003k5kt63ty72ncw: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8a003l5kt6b1mp49px: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw8a003m5kt68k125ss9: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          value: faker.random.word(),
        },
        schedule: {
          awsChaos: {
            action: faker.random.word(),
            awsRegion: faker.random.word(),
            deviceName: faker.random.word(),
            duration: faker.random.word(),
            ec2Instance: faker.random.word(),
            endpoint: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            volumeID: faker.random.word(),
          },
          azureChaos: {
            action: faker.random.word(),
            diskName: faker.random.word(),
            duration: faker.random.word(),
            lun: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            resourceGroupName: faker.random.word(),
            secretName: faker.random.word(),
            subscriptionID: faker.random.word(),
            vmName: faker.random.word(),
          },
          blockChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a003n5kt6g6vea2y2: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a003o5kt6alor3rq3: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a003p5kt6dj6o634y: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a003q5kt6baeke4ul: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a003r5kt6aifpaddr: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumeName: faker.random.word(),
          },
          concurrencyPolicy: faker.random.word(),
          dnsChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a003s5kt6cfa909h1: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a003t5kt60547ahob: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a003u5kt60sq2f9mr: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a003v5kt67u5k2gwj: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a003w5kt69ak27s7b: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          gcpChaos: {
            action: faker.random.word(),
            deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            duration: faker.random.word(),
            instance: faker.random.word(),
            project: faker.random.word(),
            remoteCluster: faker.random.word(),
            secretName: faker.random.word(),
            zone: faker.random.word(),
          },
          historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
          httpChaos: {
            abort: faker.datatype.boolean(),
            code: faker.datatype.number({ min: undefined, max: undefined }),
            delay: faker.random.word(),
            duration: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            patch: {
              body: { type: faker.random.word(), value: faker.random.word() },
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              ),
              queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              ),
            },
            path: faker.random.word(),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            replace: {
              body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined }),
              ),
              code: faker.datatype.number({ min: undefined, max: undefined }),
              headers: {
                cmauzgw8a003x5kt67i3w15x8: faker.random.word(),
              },
              method: faker.random.word(),
              path: faker.random.word(),
              queries: {
                cmauzgw8a003y5kt68ofy4m7u: faker.random.word(),
              },
            },
            request_headers: {
              cmauzgw8a003z5kt6de6y44iw: faker.random.word(),
            },
            response_headers: {
              cmauzgw8a00405kt67rsbhltj: faker.random.word(),
            },
            selector: {
              annotationSelectors: {
                cmauzgw8a00415kt6h78e1xhr: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a00425kt61mtlhb78: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a00435kt6fduid6zn: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a00445kt64y7d5y2k: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a00455kt6dnwnc4jw: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            target: faker.random.word(),
            tls: {
              caName: faker.random.word(),
              certName: faker.random.word(),
              keyName: faker.random.word(),
              secretName: faker.random.word(),
              secretNamespace: faker.random.word(),
            },
            value: faker.random.word(),
          },
          ioChaos: {
            action: faker.random.word(),
            attr: {
              atime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              blocks: faker.datatype.number({ min: undefined, max: undefined }),
              ctime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              gid: faker.datatype.number({ min: undefined, max: undefined }),
              ino: faker.datatype.number({ min: undefined, max: undefined }),
              kind: faker.random.word(),
              mtime: {
                nsec: faker.datatype.number({ min: undefined, max: undefined }),
                sec: faker.datatype.number({ min: undefined, max: undefined }),
              },
              nlink: faker.datatype.number({ min: undefined, max: undefined }),
              perm: faker.datatype.number({ min: undefined, max: undefined }),
              rdev: faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.datatype.number({ min: undefined, max: undefined }),
              uid: faker.datatype.number({ min: undefined, max: undefined }),
            },
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            delay: faker.random.word(),
            duration: faker.random.word(),
            errno: faker.datatype.number({ min: undefined, max: undefined }),
            methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            mistake: {
              filling: faker.random.word(),
              maxLength: faker.datatype.number({ min: undefined, max: undefined }),
              maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            path: faker.random.word(),
            percent: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a00465kt67kk4gtcm: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a00475kt65tnh1i2o: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a00485kt66h7s4vm2: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a00495kt6ggl1cnpd: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a004a5kt60uxscvwa: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
            volumePath: faker.random.word(),
          },
          jvmChaos: {
            action: faker.random.word(),
            class: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
            database: faker.random.word(),
            duration: faker.random.word(),
            exception: faker.random.word(),
            latency: faker.datatype.number({ min: undefined, max: undefined }),
            memType: faker.random.word(),
            method: faker.random.word(),
            mode: faker.random.word(),
            mysqlConnectorVersion: faker.random.word(),
            name: faker.random.word(),
            pid: faker.datatype.number({ min: undefined, max: undefined }),
            port: faker.datatype.number({ min: undefined, max: undefined }),
            remoteCluster: faker.random.word(),
            returnValue: faker.random.word(),
            ruleData: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a004b5kt6hmem4fdd: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a004c5kt68dpk6tb4: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a004d5kt66sro94bx: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a004e5kt6giua6u2i: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a004f5kt69a5j63ey: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            sqlType: faker.random.word(),
            table: faker.random.word(),
            value: faker.random.word(),
          },
          kernelChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            duration: faker.random.word(),
            failKernRequest: {
              callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  funcname: faker.random.word(),
                  parameters: faker.random.word(),
                  predicate: faker.random.word(),
                }),
              ),
              failtype: faker.datatype.number({ min: undefined, max: undefined }),
              headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              probability: faker.datatype.number({ min: undefined, max: undefined }),
              times: faker.datatype.number({ min: undefined, max: undefined }),
            },
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a004g5kt69g855ulx: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a004h5kt62l3s9vfd: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a004i5kt6dv234ivu: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a004j5kt673pz2ool: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a004k5kt6c1iz3p2d: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          networkChaos: {
            action: faker.random.word(),
            bandwidth: {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
            delay: {
              correlation: faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              reorder: {
                correlation: faker.random.word(),
                gap: faker.datatype.number({ min: undefined, max: undefined }),
                reorder: faker.random.word(),
              },
            },
            device: faker.random.word(),
            direction: faker.random.word(),
            duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
            duration: faker.random.word(),
            externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            loss: { correlation: faker.random.word(), loss: faker.random.word() },
            mode: faker.random.word(),
            rate: { rate: faker.random.word() },
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8a004l5kt6bml7c6l0: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8a004m5kt60tpshfhs: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8a004n5kt63d526lkl: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8a004o5kt61xkh4ouj: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8a004p5kt6ablt6o30: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            target: {
              mode: faker.random.word(),
              selector: {
                annotationSelectors: {
                  cmauzgw8a004q5kt6ccrf2nad: faker.random.word(),
                },
                expressionSelectors: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => ({
                  key: faker.random.word(),
                  operator: faker.random.word(),
                  values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word(),
                  ),
                })),
                fieldSelectors: {
                  cmauzgw8a004r5kt6a7bq2t60: faker.random.word(),
                },
                labelSelectors: {
                  cmauzgw8a004s5kt6dux2cygq: faker.random.word(),
                },
                namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word(),
                ),
                nodeSelectors: {
                  cmauzgw8a004t5kt65254fzb7: faker.random.word(),
                },
                nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
                podPhaseSelectors: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
                pods: {
                  cmauzgw8a004u5kt65832h1p8: Array.from(
                    { length: faker.datatype.number({ min: 1, max: 10 }) },
                    (_, i) => i + 1,
                  ).map(() => faker.random.word()),
                },
              },
              value: faker.random.word(),
            },
            targetDevice: faker.random.word(),
            value: faker.random.word(),
          },
          physicalmachineChaos: {
            action: faker.random.word(),
            address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            clock: {
              'clock-ids-slice': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              'time-offset': faker.random.word(),
            },
            'disk-fill': {
              'fill-by-fallocate': faker.datatype.boolean(),
              path: faker.random.word(),
              size: faker.random.word(),
            },
            'disk-read-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            'disk-write-payload': {
              path: faker.random.word(),
              'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
              size: faker.random.word(),
            },
            duration: faker.random.word(),
            'file-append': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              data: faker.random.word(),
              'file-name': faker.random.word(),
            },
            'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
            'file-modify': {
              'file-name': faker.random.word(),
              privilege: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
            'file-replace': {
              'dest-string': faker.random.word(),
              'file-name': faker.random.word(),
              line: faker.datatype.number({ min: undefined, max: undefined }),
              'origin-string': faker.random.word(),
            },
            'http-abort': {
              code: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined }),
              ),
              target: faker.random.word(),
            },
            'http-config': { file_path: faker.random.word() },
            'http-delay': {
              code: faker.random.word(),
              delay: faker.random.word(),
              method: faker.random.word(),
              path: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.datatype.number({ min: undefined, max: undefined }),
              ),
              target: faker.random.word(),
            },
            'http-request': {
              count: faker.datatype.number({ min: undefined, max: undefined }),
              'enable-conn-pool': faker.datatype.boolean(),
              url: faker.random.word(),
            },
            'jvm-exception': {
              class: faker.random.word(),
              exception: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-gc': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-latency': {
              class: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'jvm-mysql': {
              database: faker.random.word(),
              exception: faker.random.word(),
              latency: faker.datatype.number({ min: undefined, max: undefined }),
              mysqlConnectorVersion: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              sqlType: faker.random.word(),
              table: faker.random.word(),
            },
            'jvm-return': {
              class: faker.random.word(),
              method: faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              value: faker.random.word(),
            },
            'jvm-rule-data': {
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              'rule-data': faker.random.word(),
            },
            'jvm-stress': {
              'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
              'mem-type': faker.random.word(),
              pid: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'kafka-fill': {
              host: faker.random.word(),
              maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              reloadCommand: faker.random.word(),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-flood': {
              host: faker.random.word(),
              messageSize: faker.datatype.number({ min: undefined, max: undefined }),
              password: faker.random.word(),
              port: faker.datatype.number({ min: undefined, max: undefined }),
              threads: faker.datatype.number({ min: undefined, max: undefined }),
              topic: faker.random.word(),
              username: faker.random.word(),
            },
            'kafka-io': {
              configFile: faker.random.word(),
              nonReadable: faker.datatype.boolean(),
              nonWritable: faker.datatype.boolean(),
              topic: faker.random.word(),
            },
            mode: faker.random.word(),
            'network-bandwidth': {
              buffer: faker.datatype.number({ min: undefined, max: undefined }),
              device: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              limit: faker.datatype.number({ min: undefined, max: undefined }),
              minburst: faker.datatype.number({ min: undefined, max: undefined }),
              peakrate: faker.datatype.number({ min: undefined, max: undefined }),
              rate: faker.random.word(),
            },
            'network-corrupt': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-delay': {
              'accept-tcp-flags': faker.random.word(),
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              jitter: faker.random.word(),
              latency: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-dns': {
              'dns-domain-name': faker.random.word(),
              'dns-ip': faker.random.word(),
              'dns-server': faker.random.word(),
            },
            'network-down': { device: faker.random.word(), duration: faker.random.word() },
            'network-duplicate': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-flood': {
              duration: faker.random.word(),
              'ip-address': faker.random.word(),
              parallel: faker.datatype.number({ min: undefined, max: undefined }),
              port: faker.random.word(),
              rate: faker.random.word(),
            },
            'network-loss': {
              correlation: faker.random.word(),
              device: faker.random.word(),
              'egress-port': faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
              percent: faker.random.word(),
              'source-port': faker.random.word(),
            },
            'network-partition': {
              'accept-tcp-flags': faker.random.word(),
              device: faker.random.word(),
              direction: faker.random.word(),
              hostname: faker.random.word(),
              'ip-address': faker.random.word(),
              'ip-protocol': faker.random.word(),
            },
            process: {
              process: faker.random.word(),
              recoverCmd: faker.random.word(),
              signal: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-cacheLimit': {
              addr: faker.random.word(),
              cacheSize: faker.random.word(),
              password: faker.random.word(),
              percent: faker.random.word(),
            },
            'redis-expiration': {
              addr: faker.random.word(),
              expiration: faker.random.word(),
              key: faker.random.word(),
              option: faker.random.word(),
              password: faker.random.word(),
            },
            'redis-penetration': {
              addr: faker.random.word(),
              password: faker.random.word(),
              requestNum: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'redis-restart': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            'redis-stop': {
              addr: faker.random.word(),
              conf: faker.random.word(),
              flushConfig: faker.datatype.boolean(),
              password: faker.random.word(),
              redisPath: faker.datatype.boolean(),
            },
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8b004v5kt6h35camrq: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8b004w5kt63s0s5el5: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8b004x5kt6df956073: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              physicalMachines: {
                cmauzgw8b004y5kt6387e36va: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            'stress-cpu': {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            'stress-mem': {
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              size: faker.random.word(),
            },
            user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
            value: faker.random.word(),
            vm: { 'vm-name': faker.random.word() },
          },
          podChaos: {
            action: faker.random.word(),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            duration: faker.random.word(),
            gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8b004z5kt6ae6816tn: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8b00505kt63f6aawnp: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8b00515kt64ws5aqxd: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8b00525kt6dxsq7r4e: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8b00535kt60w92emec: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            value: faker.random.word(),
          },
          schedule: faker.random.word(),
          startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          stressChaos: {
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8b00545kt67myycwar: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8b00555kt6cyxacbjq: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8b00565kt6acubhed5: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8b00575kt601se9hdy: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8b00585kt695w32xld: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            stressngStressors: faker.random.word(),
            stressors: {
              cpu: {
                load: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
              memory: {
                oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
                options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
                size: faker.random.word(),
                workers: faker.datatype.number({ min: undefined, max: undefined }),
              },
            },
            value: faker.random.word(),
          },
          timeChaos: {
            clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            duration: faker.random.word(),
            mode: faker.random.word(),
            remoteCluster: faker.random.word(),
            selector: {
              annotationSelectors: {
                cmauzgw8b00595kt6ge2ldtdj: faker.random.word(),
              },
              expressionSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => ({
                key: faker.random.word(),
                operator: faker.random.word(),
                values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              })),
              fieldSelectors: {
                cmauzgw8b005a5kt672s97ubk: faker.random.word(),
              },
              labelSelectors: {
                cmauzgw8b005b5kt66fpo1pqa: faker.random.word(),
              },
              namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              nodeSelectors: {
                cmauzgw8b005c5kt6b4epbhng: faker.random.word(),
              },
              nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              podPhaseSelectors: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
              pods: {
                cmauzgw8b005d5kt6b3kg2mob: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.random.word()),
              },
            },
            timeOffset: faker.random.word(),
            value: faker.random.word(),
          },
          type: faker.random.word(),
        },
        statusCheck: {
          duration: faker.random.word(),
          failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          http: {
            body: faker.random.word(),
            criteria: { statusCode: faker.random.word() },
            headers: {
              cmauzgw8b005e5kt6fp1xg32m: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
            method: faker.random.word(),
            url: faker.random.word(),
          },
          intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          mode: faker.random.word(),
          recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
          successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
          timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          type: faker.random.word(),
        },
        stressChaos: {
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw8b005f5kt62nkhdktd: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8b005g5kt6co70eikj: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8b005h5kt65o2vewbd: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8b005i5kt62gjzdal3: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw8b005j5kt6ckztb1x6: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          stressngStressors: faker.random.word(),
          stressors: {
            cpu: {
              load: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
            memory: {
              oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
              options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              size: faker.random.word(),
              workers: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
          value: faker.random.word(),
        },
        task: {
          container: {
            args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              name: faker.random.word(),
              value: faker.random.word(),
              valueFrom: {
                configMapKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
                secretKeyRef: {
                  key: faker.random.word(),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
              },
            })),
            envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
              prefix: faker.random.word(),
              secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
            })),
            image: faker.random.word(),
            imagePullPolicy: faker.random.word(),
            lifecycle: {
              postStart: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word(),
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() }),
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
              preStop: {
                exec: {
                  command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word(),
                  ),
                },
                httpGet: {
                  host: faker.random.word(),
                  httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({ name: faker.random.word(), value: faker.random.word() }),
                  ),
                  path: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                  scheme: faker.random.word(),
                },
                tcpSocket: {
                  host: faker.random.word(),
                  port: {
                    intVal: faker.datatype.number({ min: undefined, max: undefined }),
                    strVal: faker.random.word(),
                    type: faker.datatype.number({ min: undefined, max: undefined }),
                  },
                },
              },
            },
            livenessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() }),
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            name: faker.random.word(),
            ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              containerPort: faker.datatype.number({ min: undefined, max: undefined }),
              hostIP: faker.random.word(),
              hostPort: faker.datatype.number({ min: undefined, max: undefined }),
              name: faker.random.word(),
              protocol: faker.random.word(),
            })),
            readinessProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() }),
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            resizePolicy: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ resourceName: faker.random.word(), restartPolicy: faker.random.word() }),
            ),
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                cmauzgw8c005k5kt65gly8uf1: { Format: faker.random.word() },
              },
              requests: {
                cmauzgw8c005l5kt6gkju834b: { Format: faker.random.word() },
              },
            },
            restartPolicy: faker.random.word(),
            securityContext: {
              allowPrivilegeEscalation: faker.datatype.boolean(),
              capabilities: {
                add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
                drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              },
              privileged: faker.datatype.boolean(),
              procMount: faker.random.word(),
              readOnlyRootFilesystem: faker.datatype.boolean(),
              runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
              runAsNonRoot: faker.datatype.boolean(),
              runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
              seLinuxOptions: {
                level: faker.random.word(),
                role: faker.random.word(),
                type: faker.random.word(),
                user: faker.random.word(),
              },
              seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
              windowsOptions: {
                gmsaCredentialSpec: faker.random.word(),
                gmsaCredentialSpecName: faker.random.word(),
                hostProcess: faker.datatype.boolean(),
                runAsUserName: faker.random.word(),
              },
            },
            startupProbe: {
              exec: {
                command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                  faker.random.word(),
                ),
              },
              failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
              httpGet: {
                host: faker.random.word(),
                httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({ name: faker.random.word(), value: faker.random.word() }),
                ),
                path: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
                scheme: faker.random.word(),
              },
              initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
              periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
              tcpSocket: {
                host: faker.random.word(),
                port: {
                  intVal: faker.datatype.number({ min: undefined, max: undefined }),
                  strVal: faker.random.word(),
                  type: faker.datatype.number({ min: undefined, max: undefined }),
                },
              },
              terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
              timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            },
            stdin: faker.datatype.boolean(),
            stdinOnce: faker.datatype.boolean(),
            terminationMessagePath: faker.random.word(),
            terminationMessagePolicy: faker.random.word(),
            tty: faker.datatype.boolean(),
            volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ devicePath: faker.random.word(), name: faker.random.word() }),
            ),
            volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({
                mountPath: faker.random.word(),
                mountPropagation: faker.random.word(),
                name: faker.random.word(),
                readOnly: faker.datatype.boolean(),
                subPath: faker.random.word(),
                subPathExpr: faker.random.word(),
              }),
            ),
            workingDir: faker.random.word(),
          },
          volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            awsElasticBlockStore: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            azureDisk: {
              cachingMode: faker.random.word(),
              diskName: faker.random.word(),
              diskURI: faker.random.word(),
              fsType: faker.random.word(),
              kind: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            azureFile: {
              readOnly: faker.datatype.boolean(),
              secretName: faker.random.word(),
              shareName: faker.random.word(),
            },
            cephfs: {
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretFile: faker.random.word(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            cinder: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeID: faker.random.word(),
            },
            configMap: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              name: faker.random.word(),
              optional: faker.datatype.boolean(),
            },
            csi: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              nodePublishSecretRef: { name: faker.random.word() },
              readOnly: faker.datatype.boolean(),
              volumeAttributes: {
                cmauzgw8c005m5kt640at1u55: faker.random.word(),
              },
            },
            downwardAPI: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
                resourceFieldRef: {
                  containerName: faker.random.word(),
                  divisor: { Format: faker.random.word() },
                  resource: faker.random.word(),
                },
              })),
            },
            emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
            ephemeral: {
              volumeClaimTemplate: {
                annotations: {
                  cmauzgw8c005n5kt6fihpfoju: faker.random.word(),
                },
                creationTimestamp: faker.random.word(),
                deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                deletionTimestamp: faker.random.word(),
                finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.random.word(),
                ),
                generateName: faker.random.word(),
                generation: faker.datatype.number({ min: undefined, max: undefined }),
                labels: {
                  cmauzgw8c005o5kt6av6q0r4l: faker.random.word(),
                },
                managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    apiVersion: faker.random.word(),
                    fieldsType: faker.random.word(),
                    fieldsV1: {},
                    manager: faker.random.word(),
                    operation: faker.random.word(),
                    subresource: faker.random.word(),
                    time: faker.random.word(),
                  }),
                ),
                name: faker.random.word(),
                namespace: faker.random.word(),
                ownerReferences: Array.from(
                  { length: faker.datatype.number({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => ({
                  apiVersion: faker.random.word(),
                  blockOwnerDeletion: faker.datatype.boolean(),
                  controller: faker.datatype.boolean(),
                  kind: faker.random.word(),
                  name: faker.random.word(),
                  uid: faker.random.word(),
                })),
                resourceVersion: faker.random.word(),
                selfLink: faker.random.word(),
                uid: faker.random.word(),
              },
            },
            fc: {
              fsType: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              readOnly: faker.datatype.boolean(),
              targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            },
            flexVolume: {
              driver: faker.random.word(),
              fsType: faker.random.word(),
              options: {
                cmauzgw8c005p5kt6hybfc5xk: faker.random.word(),
              },
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
            },
            flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
            gcePersistentDisk: {
              fsType: faker.random.word(),
              partition: faker.datatype.number({ min: undefined, max: undefined }),
              pdName: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
            glusterfs: {
              endpoints: faker.random.word(),
              path: faker.random.word(),
              readOnly: faker.datatype.boolean(),
            },
            hostPath: { path: faker.random.word(), type: faker.random.word() },
            iscsi: {
              chapAuthDiscovery: faker.datatype.boolean(),
              chapAuthSession: faker.datatype.boolean(),
              fsType: faker.random.word(),
              initiatorName: faker.random.word(),
              iqn: faker.random.word(),
              iscsiInterface: faker.random.word(),
              lun: faker.datatype.number({ min: undefined, max: undefined }),
              portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              targetPortal: faker.random.word(),
            },
            name: faker.random.word(),
            nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
            persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
            photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
            portworxVolume: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              volumeID: faker.random.word(),
            },
            projected: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                configMap: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    }),
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                downwardAPI: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                      resourceFieldRef: {
                        containerName: faker.random.word(),
                        divisor: { Format: faker.random.word() },
                        resource: faker.random.word(),
                      },
                    }),
                  ),
                },
                secret: {
                  items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                    () => ({
                      key: faker.random.word(),
                      mode: faker.datatype.number({ min: undefined, max: undefined }),
                      path: faker.random.word(),
                    }),
                  ),
                  name: faker.random.word(),
                  optional: faker.datatype.boolean(),
                },
                serviceAccountToken: {
                  audience: faker.random.word(),
                  expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
                  path: faker.random.word(),
                },
              })),
            },
            quobyte: {
              group: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              registry: faker.random.word(),
              tenant: faker.random.word(),
              user: faker.random.word(),
              volume: faker.random.word(),
            },
            rbd: {
              fsType: faker.random.word(),
              image: faker.random.word(),
              keyring: faker.random.word(),
              monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
              pool: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              user: faker.random.word(),
            },
            scaleIO: {
              fsType: faker.random.word(),
              gateway: faker.random.word(),
              protectionDomain: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              sslEnabled: faker.datatype.boolean(),
              storageMode: faker.random.word(),
              storagePool: faker.random.word(),
              system: faker.random.word(),
              volumeName: faker.random.word(),
            },
            secret: {
              defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
              items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                key: faker.random.word(),
                mode: faker.datatype.number({ min: undefined, max: undefined }),
                path: faker.random.word(),
              })),
              optional: faker.datatype.boolean(),
              secretName: faker.random.word(),
            },
            storageos: {
              fsType: faker.random.word(),
              readOnly: faker.datatype.boolean(),
              secretRef: { name: faker.random.word() },
              volumeName: faker.random.word(),
              volumeNamespace: faker.random.word(),
            },
            vsphereVolume: {
              fsType: faker.random.word(),
              storagePolicyID: faker.random.word(),
              storagePolicyName: faker.random.word(),
              volumePath: faker.random.word(),
            },
          })),
        },
        templateType: faker.random.word(),
        timeChaos: {
          clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          duration: faker.random.word(),
          mode: faker.random.word(),
          remoteCluster: faker.random.word(),
          selector: {
            annotationSelectors: {
              cmauzgw8d005q5kt61cv9g2xe: faker.random.word(),
            },
            expressionSelectors: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            })),
            fieldSelectors: {
              cmauzgw8d005r5kt6c3ofa5cl: faker.random.word(),
            },
            labelSelectors: {
              cmauzgw8d005s5kt6ekis9t6e: faker.random.word(),
            },
            namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            nodeSelectors: {
              cmauzgw8d005t5kt6hvjy4keu: faker.random.word(),
            },
            nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => faker.random.word(),
            ),
            pods: {
              cmauzgw8d005u5kt621cmhxu8: Array.from(
                { length: faker.datatype.number({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.random.word()),
            },
          },
          timeOffset: faker.random.word(),
          value: faker.random.word(),
        },
      })),
    },
  },
  status: {
    active: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      apiVersion: faker.random.word(),
      fieldPath: faker.random.word(),
      kind: faker.random.word(),
      name: faker.random.word(),
      namespace: faker.random.word(),
      resourceVersion: faker.random.word(),
      uid: faker.random.word(),
    })),
    time: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getDeleteSchedulesUidMock = () => ({ status: faker.random.word() })

export const getGetSchedulesUidMock = () => ({
  created_at: faker.random.word(),
  experiment_uids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word(),
  ),
  kind: faker.random.word(),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw8e005v5kt66rp5hrbt: faker.random.word(),
      },
      labels: {
        cmauzgw8e005w5kt6atkfd6cw: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  uid: faker.random.word(),
})

export const getPutSchedulesPauseUidMock = () => ({ status: faker.random.word() })

export const getPutSchedulesStartUidMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    description: faker.random.word(),
    name: faker.random.word(),
    namespace: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostTemplatesStatuschecksMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        cmauzgw8g005x5kt69jyo4q6l: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getDeleteTemplatesStatuschecksStatuscheckMock = () => ({ status: faker.random.word() })

export const getGetTemplatesStatuschecksStatuscheckMock = () => ({
  created_at: faker.random.word(),
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        cmauzgw8h005y5kt67sfe824k: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  uid: faker.random.word(),
})

export const getPutTemplatesStatuschecksStatuscheckMock = () => ({
  description: faker.random.word(),
  name: faker.random.word(),
  namespace: faker.random.word(),
  spec: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        cmauzgw8h005z5kt67xnif33w: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
})

export const getGetWorkflowsMock = () =>
  Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: faker.random.word(),
    end_time: faker.random.word(),
    entry: faker.random.word(),
    finish_time: faker.random.word(),
    id: faker.datatype.number({ min: undefined, max: undefined }),
    name: faker.random.word(),
    namespace: faker.random.word(),
    status: faker.random.word(),
    uid: faker.random.word(),
  }))

export const getPostWorkflowsMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw8j00605kt6fe8b5v0j: faker.random.word(),
      },
      labels: {
        cmauzgw8j00615kt66d3vcerk: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() }),
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getDeleteWorkflowsUidMock = () => ({ status: faker.random.word() })

export const getGetWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw8k00625kt66z5x1dqf: faker.random.word(),
      },
      labels: {
        cmauzgw8k00635kt643bn16nt: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() }),
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPutWorkflowsUidMock = () => ({
  created_at: faker.random.word(),
  end_time: faker.random.word(),
  entry: faker.random.word(),
  finish_time: faker.random.word(),
  id: faker.datatype.number({ min: undefined, max: undefined }),
  kube_object: {
    apiVersion: faker.random.word(),
    kind: faker.random.word(),
    metadata: {
      annotations: {
        cmauzgw8k00645kt61jjmbx6k: faker.random.word(),
      },
      labels: {
        cmauzgw8k00655kt61r236y04: faker.random.word(),
      },
      name: faker.random.word(),
      namespace: faker.random.word(),
    },
    spec: {},
  },
  name: faker.random.word(),
  namespace: faker.random.word(),
  status: faker.random.word(),
  topology: {
    nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      conditional_branches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({ expression: faker.random.word(), name: faker.random.word(), template: faker.random.word() }),
      ),
      name: faker.random.word(),
      parallel: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      serial: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        template: faker.random.word(),
      })),
      state: faker.random.word(),
      template: faker.random.word(),
      type: faker.random.word(),
      uid: faker.random.word(),
    })),
  },
  uid: faker.random.word(),
})

export const getPostWorkflowsParseTaskHttpMock = () => ({
  body: faker.random.word(),
  followLocation: faker.datatype.boolean(),
  header: {
    cmauzgw8l00665kt639p78fbx: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
      () => faker.random.word(),
    ),
  },
  jsonContent: faker.datatype.boolean(),
  method: faker.random.word(),
  name: faker.random.word(),
  url: faker.random.word(),
})

export const getPostWorkflowsRenderTaskHttpMock = () => ({
  abortWithStatusCheck: faker.datatype.boolean(),
  awsChaos: {
    action: faker.random.word(),
    awsRegion: faker.random.word(),
    deviceName: faker.random.word(),
    duration: faker.random.word(),
    ec2Instance: faker.random.word(),
    endpoint: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    volumeID: faker.random.word(),
  },
  azureChaos: {
    action: faker.random.word(),
    diskName: faker.random.word(),
    duration: faker.random.word(),
    lun: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    resourceGroupName: faker.random.word(),
    secretName: faker.random.word(),
    subscriptionID: faker.random.word(),
    vmName: faker.random.word(),
  },
  blockChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8l00675kt6hhb573su: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8l00685kt6bph14lyv: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8l00695kt67exv9zoh: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m006a5kt6bwchbest: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m006b5kt64kbf0jd2: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumeName: faker.random.word(),
  },
  children: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.random.word(),
  ),
  conditionalBranches: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    expression: faker.random.word(),
    target: faker.random.word(),
  })),
  deadline: faker.random.word(),
  dnsChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8m006c5kt62i0chcg0: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m006d5kt6b4ux4615: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m006e5kt60fc3feoh: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m006f5kt61k3c415v: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m006g5kt6c9rn7maw: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  gcpChaos: {
    action: faker.random.word(),
    deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    instance: faker.random.word(),
    project: faker.random.word(),
    remoteCluster: faker.random.word(),
    secretName: faker.random.word(),
    zone: faker.random.word(),
  },
  httpChaos: {
    abort: faker.datatype.boolean(),
    code: faker.datatype.number({ min: undefined, max: undefined }),
    delay: faker.random.word(),
    duration: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    patch: {
      body: { type: faker.random.word(), value: faker.random.word() },
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
      ),
      queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
      ),
    },
    path: faker.random.word(),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    replace: {
      body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined }),
      ),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      headers: {
        cmauzgw8m006h5kt679qh8j4e: faker.random.word(),
      },
      method: faker.random.word(),
      path: faker.random.word(),
      queries: {
        cmauzgw8m006i5kt62wld61dm: faker.random.word(),
      },
    },
    request_headers: {
      cmauzgw8m006j5kt68gtz5bl2: faker.random.word(),
    },
    response_headers: {
      cmauzgw8m006k5kt67mnr5na2: faker.random.word(),
    },
    selector: {
      annotationSelectors: {
        cmauzgw8m006l5kt654cyav6n: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m006m5kt6evk89g6j: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m006n5kt68t6n69sc: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m006o5kt694t5cwxo: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m006p5kt615715oc0: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    target: faker.random.word(),
    tls: {
      caName: faker.random.word(),
      certName: faker.random.word(),
      keyName: faker.random.word(),
      secretName: faker.random.word(),
      secretNamespace: faker.random.word(),
    },
    value: faker.random.word(),
  },
  ioChaos: {
    action: faker.random.word(),
    attr: {
      atime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      blocks: faker.datatype.number({ min: undefined, max: undefined }),
      ctime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      gid: faker.datatype.number({ min: undefined, max: undefined }),
      ino: faker.datatype.number({ min: undefined, max: undefined }),
      kind: faker.random.word(),
      mtime: {
        nsec: faker.datatype.number({ min: undefined, max: undefined }),
        sec: faker.datatype.number({ min: undefined, max: undefined }),
      },
      nlink: faker.datatype.number({ min: undefined, max: undefined }),
      perm: faker.datatype.number({ min: undefined, max: undefined }),
      rdev: faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.datatype.number({ min: undefined, max: undefined }),
      uid: faker.datatype.number({ min: undefined, max: undefined }),
    },
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    delay: faker.random.word(),
    duration: faker.random.word(),
    errno: faker.datatype.number({ min: undefined, max: undefined }),
    methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    mistake: {
      filling: faker.random.word(),
      maxLength: faker.datatype.number({ min: undefined, max: undefined }),
      maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    path: faker.random.word(),
    percent: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8m006q5kt620ww78cw: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m006r5kt666g2fw96: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m006s5kt601ylfval: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m006t5kt6c4wwc5fy: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m006u5kt6eodc3pjz: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
    volumePath: faker.random.word(),
  },
  jvmChaos: {
    action: faker.random.word(),
    class: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
    database: faker.random.word(),
    duration: faker.random.word(),
    exception: faker.random.word(),
    latency: faker.datatype.number({ min: undefined, max: undefined }),
    memType: faker.random.word(),
    method: faker.random.word(),
    mode: faker.random.word(),
    mysqlConnectorVersion: faker.random.word(),
    name: faker.random.word(),
    pid: faker.datatype.number({ min: undefined, max: undefined }),
    port: faker.datatype.number({ min: undefined, max: undefined }),
    remoteCluster: faker.random.word(),
    returnValue: faker.random.word(),
    ruleData: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8m006v5kt678arfbbm: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m006w5kt6dzkbf6g7: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m006x5kt6epw44pph: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m006y5kt66ssj7y2d: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m006z5kt6h3d0ff9e: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    sqlType: faker.random.word(),
    table: faker.random.word(),
    value: faker.random.word(),
  },
  kernelChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    failKernRequest: {
      callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        funcname: faker.random.word(),
        parameters: faker.random.word(),
        predicate: faker.random.word(),
      })),
      failtype: faker.datatype.number({ min: undefined, max: undefined }),
      headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      probability: faker.datatype.number({ min: undefined, max: undefined }),
      times: faker.datatype.number({ min: undefined, max: undefined }),
    },
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8m00705kt6bohc2zlw: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m00715kt6bm2ic4jy: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m00725kt65io93v8q: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m00735kt6fz2p38wv: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m00745kt6dfce7z91: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  name: faker.random.word(),
  networkChaos: {
    action: faker.random.word(),
    bandwidth: {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
    delay: {
      correlation: faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      reorder: {
        correlation: faker.random.word(),
        gap: faker.datatype.number({ min: undefined, max: undefined }),
        reorder: faker.random.word(),
      },
    },
    device: faker.random.word(),
    direction: faker.random.word(),
    duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
    duration: faker.random.word(),
    externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    loss: { correlation: faker.random.word(), loss: faker.random.word() },
    mode: faker.random.word(),
    rate: { rate: faker.random.word() },
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8m00755kt6157qdo3q: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8m00765kt64cv32n58: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8m00775kt6bjz77e3i: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8m00785kt6dwh42mbl: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8m00795kt64quv0muw: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    target: {
      mode: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8m007a5kt67ak08irm: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8m007b5kt62vs66dqr: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8m007c5kt600ns94z2: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8m007d5kt63w0x6euo: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8m007e5kt67fnucnhu: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    targetDevice: faker.random.word(),
    value: faker.random.word(),
  },
  physicalmachineChaos: {
    action: faker.random.word(),
    address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    clock: {
      'clock-ids-slice': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      'time-offset': faker.random.word(),
    },
    'disk-fill': {
      'fill-by-fallocate': faker.datatype.boolean(),
      path: faker.random.word(),
      size: faker.random.word(),
    },
    'disk-read-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    'disk-write-payload': {
      path: faker.random.word(),
      'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
      size: faker.random.word(),
    },
    duration: faker.random.word(),
    'file-append': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      data: faker.random.word(),
      'file-name': faker.random.word(),
    },
    'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
    'file-modify': {
      'file-name': faker.random.word(),
      privilege: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
    'file-replace': {
      'dest-string': faker.random.word(),
      'file-name': faker.random.word(),
      line: faker.datatype.number({ min: undefined, max: undefined }),
      'origin-string': faker.random.word(),
    },
    'http-abort': {
      code: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined }),
      ),
      target: faker.random.word(),
    },
    'http-config': { file_path: faker.random.word() },
    'http-delay': {
      code: faker.random.word(),
      delay: faker.random.word(),
      method: faker.random.word(),
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.datatype.number({ min: undefined, max: undefined }),
      ),
      target: faker.random.word(),
    },
    'http-request': {
      count: faker.datatype.number({ min: undefined, max: undefined }),
      'enable-conn-pool': faker.datatype.boolean(),
      url: faker.random.word(),
    },
    'jvm-exception': {
      class: faker.random.word(),
      exception: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-gc': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-latency': {
      class: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'jvm-mysql': {
      database: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      mysqlConnectorVersion: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      sqlType: faker.random.word(),
      table: faker.random.word(),
    },
    'jvm-return': {
      class: faker.random.word(),
      method: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      value: faker.random.word(),
    },
    'jvm-rule-data': {
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      'rule-data': faker.random.word(),
    },
    'jvm-stress': {
      'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
      'mem-type': faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'kafka-fill': {
      host: faker.random.word(),
      maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      reloadCommand: faker.random.word(),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-flood': {
      host: faker.random.word(),
      messageSize: faker.datatype.number({ min: undefined, max: undefined }),
      password: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      threads: faker.datatype.number({ min: undefined, max: undefined }),
      topic: faker.random.word(),
      username: faker.random.word(),
    },
    'kafka-io': {
      configFile: faker.random.word(),
      nonReadable: faker.datatype.boolean(),
      nonWritable: faker.datatype.boolean(),
      topic: faker.random.word(),
    },
    mode: faker.random.word(),
    'network-bandwidth': {
      buffer: faker.datatype.number({ min: undefined, max: undefined }),
      device: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      limit: faker.datatype.number({ min: undefined, max: undefined }),
      minburst: faker.datatype.number({ min: undefined, max: undefined }),
      peakrate: faker.datatype.number({ min: undefined, max: undefined }),
      rate: faker.random.word(),
    },
    'network-corrupt': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-delay': {
      'accept-tcp-flags': faker.random.word(),
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      jitter: faker.random.word(),
      latency: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-dns': {
      'dns-domain-name': faker.random.word(),
      'dns-ip': faker.random.word(),
      'dns-server': faker.random.word(),
    },
    'network-down': { device: faker.random.word(), duration: faker.random.word() },
    'network-duplicate': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-flood': {
      duration: faker.random.word(),
      'ip-address': faker.random.word(),
      parallel: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.random.word(),
      rate: faker.random.word(),
    },
    'network-loss': {
      correlation: faker.random.word(),
      device: faker.random.word(),
      'egress-port': faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
      percent: faker.random.word(),
      'source-port': faker.random.word(),
    },
    'network-partition': {
      'accept-tcp-flags': faker.random.word(),
      device: faker.random.word(),
      direction: faker.random.word(),
      hostname: faker.random.word(),
      'ip-address': faker.random.word(),
      'ip-protocol': faker.random.word(),
    },
    process: {
      process: faker.random.word(),
      recoverCmd: faker.random.word(),
      signal: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-cacheLimit': {
      addr: faker.random.word(),
      cacheSize: faker.random.word(),
      password: faker.random.word(),
      percent: faker.random.word(),
    },
    'redis-expiration': {
      addr: faker.random.word(),
      expiration: faker.random.word(),
      key: faker.random.word(),
      option: faker.random.word(),
      password: faker.random.word(),
    },
    'redis-penetration': {
      addr: faker.random.word(),
      password: faker.random.word(),
      requestNum: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'redis-restart': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    'redis-stop': {
      addr: faker.random.word(),
      conf: faker.random.word(),
      flushConfig: faker.datatype.boolean(),
      password: faker.random.word(),
      redisPath: faker.datatype.boolean(),
    },
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8n007f5kt6f4rvfm5x: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8n007g5kt61ofe54h3: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8n007h5kt60zcrfb5s: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      physicalMachines: {
        cmauzgw8n007i5kt6e2uh18dt: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    'stress-cpu': {
      load: faker.datatype.number({ min: undefined, max: undefined }),
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      workers: faker.datatype.number({ min: undefined, max: undefined }),
    },
    'stress-mem': {
      options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      size: faker.random.word(),
    },
    user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
    value: faker.random.word(),
    vm: { 'vm-name': faker.random.word() },
  },
  podChaos: {
    action: faker.random.word(),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8n007j5kt65mi63qea: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8n007k5kt688n9dhw3: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8n007l5kt6bv7462ng: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8n007m5kt6899cc1nr: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8n007n5kt6doc60677: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    value: faker.random.word(),
  },
  schedule: {
    awsChaos: {
      action: faker.random.word(),
      awsRegion: faker.random.word(),
      deviceName: faker.random.word(),
      duration: faker.random.word(),
      ec2Instance: faker.random.word(),
      endpoint: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      volumeID: faker.random.word(),
    },
    azureChaos: {
      action: faker.random.word(),
      diskName: faker.random.word(),
      duration: faker.random.word(),
      lun: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      resourceGroupName: faker.random.word(),
      secretName: faker.random.word(),
      subscriptionID: faker.random.word(),
      vmName: faker.random.word(),
    },
    blockChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      delay: { correlation: faker.random.word(), jitter: faker.random.word(), latency: faker.random.word() },
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8n007o5kt66oa4bkt1: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8n007p5kt66cbb6l9c: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8n007q5kt60r3zdgyq: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8n007r5kt63hend5pn: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8n007s5kt6b3zwg8rm: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumeName: faker.random.word(),
    },
    concurrencyPolicy: faker.random.word(),
    dnsChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      patterns: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8n007t5kt65el55r67: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8n007u5kt65q9w1eys: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8n007v5kt6h6fd81st: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8n007w5kt60afigp4o: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8n007x5kt6dtsoaefh: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    gcpChaos: {
      action: faker.random.word(),
      deviceNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      instance: faker.random.word(),
      project: faker.random.word(),
      remoteCluster: faker.random.word(),
      secretName: faker.random.word(),
      zone: faker.random.word(),
    },
    historyLimit: faker.datatype.number({ min: undefined, max: undefined }),
    httpChaos: {
      abort: faker.datatype.boolean(),
      code: faker.datatype.number({ min: undefined, max: undefined }),
      delay: faker.random.word(),
      duration: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      patch: {
        body: { type: faker.random.word(), value: faker.random.word() },
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        ),
        queries: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        ),
      },
      path: faker.random.word(),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      replace: {
        body: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        code: faker.datatype.number({ min: undefined, max: undefined }),
        headers: {
          cmauzgw8n007y5kt623u0a59a: faker.random.word(),
        },
        method: faker.random.word(),
        path: faker.random.word(),
        queries: {
          cmauzgw8n007z5kt6ht412qvm: faker.random.word(),
        },
      },
      request_headers: {
        cmauzgw8n00805kt67te1cyyj: faker.random.word(),
      },
      response_headers: {
        cmauzgw8n00815kt6am671crb: faker.random.word(),
      },
      selector: {
        annotationSelectors: {
          cmauzgw8n00825kt681m0cjak: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8n00835kt62rgc5w59: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8n00845kt6ctvb029y: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8n00855kt6dz9k4nks: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8n00865kt60dr528qu: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      target: faker.random.word(),
      tls: {
        caName: faker.random.word(),
        certName: faker.random.word(),
        keyName: faker.random.word(),
        secretName: faker.random.word(),
        secretNamespace: faker.random.word(),
      },
      value: faker.random.word(),
    },
    ioChaos: {
      action: faker.random.word(),
      attr: {
        atime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        blocks: faker.datatype.number({ min: undefined, max: undefined }),
        ctime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        gid: faker.datatype.number({ min: undefined, max: undefined }),
        ino: faker.datatype.number({ min: undefined, max: undefined }),
        kind: faker.random.word(),
        mtime: {
          nsec: faker.datatype.number({ min: undefined, max: undefined }),
          sec: faker.datatype.number({ min: undefined, max: undefined }),
        },
        nlink: faker.datatype.number({ min: undefined, max: undefined }),
        perm: faker.datatype.number({ min: undefined, max: undefined }),
        rdev: faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.datatype.number({ min: undefined, max: undefined }),
        uid: faker.datatype.number({ min: undefined, max: undefined }),
      },
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      delay: faker.random.word(),
      duration: faker.random.word(),
      errno: faker.datatype.number({ min: undefined, max: undefined }),
      methods: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      mistake: {
        filling: faker.random.word(),
        maxLength: faker.datatype.number({ min: undefined, max: undefined }),
        maxOccurrences: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      path: faker.random.word(),
      percent: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8n00875kt68trd3evh: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8n00885kt68fft07pl: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8n00895kt6f0m83cuq: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8n008a5kt6dkn60827: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8n008b5kt652rn5bwc: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
      volumePath: faker.random.word(),
    },
    jvmChaos: {
      action: faker.random.word(),
      class: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      cpuCount: faker.datatype.number({ min: undefined, max: undefined }),
      database: faker.random.word(),
      duration: faker.random.word(),
      exception: faker.random.word(),
      latency: faker.datatype.number({ min: undefined, max: undefined }),
      memType: faker.random.word(),
      method: faker.random.word(),
      mode: faker.random.word(),
      mysqlConnectorVersion: faker.random.word(),
      name: faker.random.word(),
      pid: faker.datatype.number({ min: undefined, max: undefined }),
      port: faker.datatype.number({ min: undefined, max: undefined }),
      remoteCluster: faker.random.word(),
      returnValue: faker.random.word(),
      ruleData: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8n008c5kt6fxr1glgf: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8n008d5kt6b5ke3noo: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8n008e5kt64tdr4soo: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8n008f5kt63ql0crg1: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8n008g5kt6dyckado7: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      sqlType: faker.random.word(),
      table: faker.random.word(),
      value: faker.random.word(),
    },
    kernelChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      failKernRequest: {
        callchain: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          funcname: faker.random.word(),
          parameters: faker.random.word(),
          predicate: faker.random.word(),
        })),
        failtype: faker.datatype.number({ min: undefined, max: undefined }),
        headers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        probability: faker.datatype.number({ min: undefined, max: undefined }),
        times: faker.datatype.number({ min: undefined, max: undefined }),
      },
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8n008h5kt661jv4xls: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o008i5kt64c8ka078: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o008j5kt6al4j4u0b: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8o008k5kt63xa978uk: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8o008l5kt695vc0fcu: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    networkChaos: {
      action: faker.random.word(),
      bandwidth: {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      corrupt: { correlation: faker.random.word(), corrupt: faker.random.word() },
      delay: {
        correlation: faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        reorder: {
          correlation: faker.random.word(),
          gap: faker.datatype.number({ min: undefined, max: undefined }),
          reorder: faker.random.word(),
        },
      },
      device: faker.random.word(),
      direction: faker.random.word(),
      duplicate: { correlation: faker.random.word(), duplicate: faker.random.word() },
      duration: faker.random.word(),
      externalTargets: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      loss: { correlation: faker.random.word(), loss: faker.random.word() },
      mode: faker.random.word(),
      rate: { rate: faker.random.word() },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8o008m5kt6bg2wcbld: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o008n5kt6hcoq33vm: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o008o5kt6b6tw8xf0: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8o008p5kt6fp33fyra: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8o008q5kt69rhkhpe2: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      target: {
        mode: faker.random.word(),
        selector: {
          annotationSelectors: {
            cmauzgw8o008r5kt6e51m8jz5: faker.random.word(),
          },
          expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              key: faker.random.word(),
              operator: faker.random.word(),
              values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                faker.random.word(),
              ),
            }),
          ),
          fieldSelectors: {
            cmauzgw8o008s5kt69cmhewlx: faker.random.word(),
          },
          labelSelectors: {
            cmauzgw8o008t5kt61ion2fpc: faker.random.word(),
          },
          namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          nodeSelectors: {
            cmauzgw8o008u5kt65o012zmo: faker.random.word(),
          },
          nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => faker.random.word(),
          ),
          pods: {
            cmauzgw8o008v5kt66i3l0f5p: Array.from(
              { length: faker.datatype.number({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => faker.random.word()),
          },
        },
        value: faker.random.word(),
      },
      targetDevice: faker.random.word(),
      value: faker.random.word(),
    },
    physicalmachineChaos: {
      action: faker.random.word(),
      address: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      clock: {
        'clock-ids-slice': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        'time-offset': faker.random.word(),
      },
      'disk-fill': {
        'fill-by-fallocate': faker.datatype.boolean(),
        path: faker.random.word(),
        size: faker.random.word(),
      },
      'disk-read-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      'disk-write-payload': {
        path: faker.random.word(),
        'payload-process-num': faker.datatype.number({ min: undefined, max: undefined }),
        size: faker.random.word(),
      },
      duration: faker.random.word(),
      'file-append': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        data: faker.random.word(),
        'file-name': faker.random.word(),
      },
      'file-create': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-delete': { 'dir-name': faker.random.word(), 'file-name': faker.random.word() },
      'file-modify': {
        'file-name': faker.random.word(),
        privilege: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'file-rename': { 'dest-file': faker.random.word(), 'source-file': faker.random.word() },
      'file-replace': {
        'dest-string': faker.random.word(),
        'file-name': faker.random.word(),
        line: faker.datatype.number({ min: undefined, max: undefined }),
        'origin-string': faker.random.word(),
      },
      'http-abort': {
        code: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        target: faker.random.word(),
      },
      'http-config': { file_path: faker.random.word() },
      'http-delay': {
        code: faker.random.word(),
        delay: faker.random.word(),
        method: faker.random.word(),
        path: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        proxy_ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.datatype.number({ min: undefined, max: undefined }),
        ),
        target: faker.random.word(),
      },
      'http-request': {
        count: faker.datatype.number({ min: undefined, max: undefined }),
        'enable-conn-pool': faker.datatype.boolean(),
        url: faker.random.word(),
      },
      'jvm-exception': {
        class: faker.random.word(),
        exception: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-gc': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-latency': {
        class: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'jvm-mysql': {
        database: faker.random.word(),
        exception: faker.random.word(),
        latency: faker.datatype.number({ min: undefined, max: undefined }),
        mysqlConnectorVersion: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        sqlType: faker.random.word(),
        table: faker.random.word(),
      },
      'jvm-return': {
        class: faker.random.word(),
        method: faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        value: faker.random.word(),
      },
      'jvm-rule-data': {
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        'rule-data': faker.random.word(),
      },
      'jvm-stress': {
        'cpu-count': faker.datatype.number({ min: undefined, max: undefined }),
        'mem-type': faker.random.word(),
        pid: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'kafka-fill': {
        host: faker.random.word(),
        maxBytes: faker.datatype.number({ min: undefined, max: undefined }),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        reloadCommand: faker.random.word(),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-flood': {
        host: faker.random.word(),
        messageSize: faker.datatype.number({ min: undefined, max: undefined }),
        password: faker.random.word(),
        port: faker.datatype.number({ min: undefined, max: undefined }),
        threads: faker.datatype.number({ min: undefined, max: undefined }),
        topic: faker.random.word(),
        username: faker.random.word(),
      },
      'kafka-io': {
        configFile: faker.random.word(),
        nonReadable: faker.datatype.boolean(),
        nonWritable: faker.datatype.boolean(),
        topic: faker.random.word(),
      },
      mode: faker.random.word(),
      'network-bandwidth': {
        buffer: faker.datatype.number({ min: undefined, max: undefined }),
        device: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        limit: faker.datatype.number({ min: undefined, max: undefined }),
        minburst: faker.datatype.number({ min: undefined, max: undefined }),
        peakrate: faker.datatype.number({ min: undefined, max: undefined }),
        rate: faker.random.word(),
      },
      'network-corrupt': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-delay': {
        'accept-tcp-flags': faker.random.word(),
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        jitter: faker.random.word(),
        latency: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-dns': {
        'dns-domain-name': faker.random.word(),
        'dns-ip': faker.random.word(),
        'dns-server': faker.random.word(),
      },
      'network-down': { device: faker.random.word(), duration: faker.random.word() },
      'network-duplicate': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-flood': {
        duration: faker.random.word(),
        'ip-address': faker.random.word(),
        parallel: faker.datatype.number({ min: undefined, max: undefined }),
        port: faker.random.word(),
        rate: faker.random.word(),
      },
      'network-loss': {
        correlation: faker.random.word(),
        device: faker.random.word(),
        'egress-port': faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
        percent: faker.random.word(),
        'source-port': faker.random.word(),
      },
      'network-partition': {
        'accept-tcp-flags': faker.random.word(),
        device: faker.random.word(),
        direction: faker.random.word(),
        hostname: faker.random.word(),
        'ip-address': faker.random.word(),
        'ip-protocol': faker.random.word(),
      },
      process: {
        process: faker.random.word(),
        recoverCmd: faker.random.word(),
        signal: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-cacheLimit': {
        addr: faker.random.word(),
        cacheSize: faker.random.word(),
        password: faker.random.word(),
        percent: faker.random.word(),
      },
      'redis-expiration': {
        addr: faker.random.word(),
        expiration: faker.random.word(),
        key: faker.random.word(),
        option: faker.random.word(),
        password: faker.random.word(),
      },
      'redis-penetration': {
        addr: faker.random.word(),
        password: faker.random.word(),
        requestNum: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'redis-restart': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      'redis-stop': {
        addr: faker.random.word(),
        conf: faker.random.word(),
        flushConfig: faker.datatype.boolean(),
        password: faker.random.word(),
        redisPath: faker.datatype.boolean(),
      },
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8o008w5kt6esj76hhb: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o008x5kt6fvinej8m: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o008y5kt67nr24okl: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        physicalMachines: {
          cmauzgw8o008z5kt63moi9apt: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      'stress-cpu': {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      'stress-mem': {
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        size: faker.random.word(),
      },
      user_defined: { attackCmd: faker.random.word(), recoverCmd: faker.random.word() },
      value: faker.random.word(),
      vm: { 'vm-name': faker.random.word() },
    },
    podChaos: {
      action: faker.random.word(),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      gracePeriod: faker.datatype.number({ min: undefined, max: undefined }),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8o00905kt61bjy82eh: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o00915kt65plf95rm: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o00925kt6fkfq7o2c: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8o00935kt661zf5j1i: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8o00945kt69g031ki9: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      value: faker.random.word(),
    },
    schedule: faker.random.word(),
    startingDeadlineSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    stressChaos: {
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8o00955kt6gbw6g5mx: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o00965kt69wi11e44: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o00975kt6gp87d6tm: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8o00985kt6adu04oy4: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8o00995kt69ovt337s: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      stressngStressors: faker.random.word(),
      stressors: {
        cpu: {
          load: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
        memory: {
          oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
          options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          size: faker.random.word(),
          workers: faker.datatype.number({ min: undefined, max: undefined }),
        },
      },
      value: faker.random.word(),
    },
    timeChaos: {
      clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      duration: faker.random.word(),
      mode: faker.random.word(),
      remoteCluster: faker.random.word(),
      selector: {
        annotationSelectors: {
          cmauzgw8o009a5kt66wr72d1x: faker.random.word(),
        },
        expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
          () => ({
            key: faker.random.word(),
            operator: faker.random.word(),
            values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          }),
        ),
        fieldSelectors: {
          cmauzgw8o009b5kt6a1ym39c3: faker.random.word(),
        },
        labelSelectors: {
          cmauzgw8o009c5kt6edlehb3q: faker.random.word(),
        },
        namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        nodeSelectors: {
          cmauzgw8o009d5kt6adb26leu: faker.random.word(),
        },
        nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pods: {
          cmauzgw8o009e5kt66ka4d7rh: Array.from(
            { length: faker.datatype.number({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.random.word()),
        },
      },
      timeOffset: faker.random.word(),
      value: faker.random.word(),
    },
    type: faker.random.word(),
  },
  statusCheck: {
    duration: faker.random.word(),
    failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    http: {
      body: faker.random.word(),
      criteria: { statusCode: faker.random.word() },
      headers: {
        cmauzgw8p009f5kt61jwu9x9z: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
      method: faker.random.word(),
      url: faker.random.word(),
    },
    intervalSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    mode: faker.random.word(),
    recordsHistoryLimit: faker.datatype.number({ min: undefined, max: undefined }),
    successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
    timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
    type: faker.random.word(),
  },
  stressChaos: {
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8p009g5kt6f5pq77o8: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8p009h5kt677z39mos: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8p009i5kt6clnp3ov9: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8p009j5kt65cm18swz: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8p009k5kt620j15zq1: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    stressngStressors: faker.random.word(),
    stressors: {
      cpu: {
        load: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
      memory: {
        oomScoreAdj: faker.datatype.number({ min: undefined, max: undefined }),
        options: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        size: faker.random.word(),
        workers: faker.datatype.number({ min: undefined, max: undefined }),
      },
    },
    value: faker.random.word(),
  },
  task: {
    container: {
      args: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      env: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        name: faker.random.word(),
        value: faker.random.word(),
        valueFrom: {
          configMapKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
          secretKeyRef: { key: faker.random.word(), name: faker.random.word(), optional: faker.datatype.boolean() },
        },
      })),
      envFrom: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        configMapRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
        prefix: faker.random.word(),
        secretRef: { name: faker.random.word(), optional: faker.datatype.boolean() },
      })),
      image: faker.random.word(),
      imagePullPolicy: faker.random.word(),
      lifecycle: {
        postStart: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() }),
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
        preStop: {
          exec: {
            command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
          },
          httpGet: {
            host: faker.random.word(),
            httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ name: faker.random.word(), value: faker.random.word() }),
            ),
            path: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
            scheme: faker.random.word(),
          },
          tcpSocket: {
            host: faker.random.word(),
            port: {
              intVal: faker.datatype.number({ min: undefined, max: undefined }),
              strVal: faker.random.word(),
              type: faker.datatype.number({ min: undefined, max: undefined }),
            },
          },
        },
      },
      livenessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      name: faker.random.word(),
      ports: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        containerPort: faker.datatype.number({ min: undefined, max: undefined }),
        hostIP: faker.random.word(),
        hostPort: faker.datatype.number({ min: undefined, max: undefined }),
        name: faker.random.word(),
        protocol: faker.random.word(),
      })),
      readinessProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      resizePolicy: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        resourceName: faker.random.word(),
        restartPolicy: faker.random.word(),
      })),
      resources: {
        claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          name: faker.random.word(),
        })),
        limits: {
          cmauzgw8p009l5kt6hswlcor5: { Format: faker.random.word() },
        },
        requests: {
          cmauzgw8p009m5kt6cezw6zd8: { Format: faker.random.word() },
        },
      },
      restartPolicy: faker.random.word(),
      securityContext: {
        allowPrivilegeEscalation: faker.datatype.boolean(),
        capabilities: {
          add: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          drop: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        },
        privileged: faker.datatype.boolean(),
        procMount: faker.random.word(),
        readOnlyRootFilesystem: faker.datatype.boolean(),
        runAsGroup: faker.datatype.number({ min: undefined, max: undefined }),
        runAsNonRoot: faker.datatype.boolean(),
        runAsUser: faker.datatype.number({ min: undefined, max: undefined }),
        seLinuxOptions: {
          level: faker.random.word(),
          role: faker.random.word(),
          type: faker.random.word(),
          user: faker.random.word(),
        },
        seccompProfile: { localhostProfile: faker.random.word(), type: faker.random.word() },
        windowsOptions: {
          gmsaCredentialSpec: faker.random.word(),
          gmsaCredentialSpecName: faker.random.word(),
          hostProcess: faker.datatype.boolean(),
          runAsUserName: faker.random.word(),
        },
      },
      startupProbe: {
        exec: {
          command: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        },
        failureThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        grpc: { port: faker.datatype.number({ min: undefined, max: undefined }), service: faker.random.word() },
        httpGet: {
          host: faker.random.word(),
          httpHeaders: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
            name: faker.random.word(),
            value: faker.random.word(),
          })),
          path: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
          scheme: faker.random.word(),
        },
        initialDelaySeconds: faker.datatype.number({ min: undefined, max: undefined }),
        periodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        successThreshold: faker.datatype.number({ min: undefined, max: undefined }),
        tcpSocket: {
          host: faker.random.word(),
          port: {
            intVal: faker.datatype.number({ min: undefined, max: undefined }),
            strVal: faker.random.word(),
            type: faker.datatype.number({ min: undefined, max: undefined }),
          },
        },
        terminationGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
        timeoutSeconds: faker.datatype.number({ min: undefined, max: undefined }),
      },
      stdin: faker.datatype.boolean(),
      stdinOnce: faker.datatype.boolean(),
      terminationMessagePath: faker.random.word(),
      terminationMessagePolicy: faker.random.word(),
      tty: faker.datatype.boolean(),
      volumeDevices: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        devicePath: faker.random.word(),
        name: faker.random.word(),
      })),
      volumeMounts: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        mountPath: faker.random.word(),
        mountPropagation: faker.random.word(),
        name: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        subPath: faker.random.word(),
        subPathExpr: faker.random.word(),
      })),
      workingDir: faker.random.word(),
    },
    volumes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      awsElasticBlockStore: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      azureDisk: {
        cachingMode: faker.random.word(),
        diskName: faker.random.word(),
        diskURI: faker.random.word(),
        fsType: faker.random.word(),
        kind: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      azureFile: {
        readOnly: faker.datatype.boolean(),
        secretName: faker.random.word(),
        shareName: faker.random.word(),
      },
      cephfs: {
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        path: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretFile: faker.random.word(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      cinder: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeID: faker.random.word(),
      },
      configMap: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        name: faker.random.word(),
        optional: faker.datatype.boolean(),
      },
      csi: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        nodePublishSecretRef: { name: faker.random.word() },
        readOnly: faker.datatype.boolean(),
        volumeAttributes: {
          cmauzgw8p009n5kt6h8lt9q59: faker.random.word(),
        },
      },
      downwardAPI: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
          resourceFieldRef: {
            containerName: faker.random.word(),
            divisor: { Format: faker.random.word() },
            resource: faker.random.word(),
          },
        })),
      },
      emptyDir: { medium: faker.random.word(), sizeLimit: { Format: faker.random.word() } },
      ephemeral: {
        volumeClaimTemplate: {
          annotations: {
            cmauzgw8p009o5kt69jer7i6v: faker.random.word(),
          },
          creationTimestamp: faker.random.word(),
          deletionGracePeriodSeconds: faker.datatype.number({ min: undefined, max: undefined }),
          deletionTimestamp: faker.random.word(),
          finalizers: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
          generateName: faker.random.word(),
          generation: faker.datatype.number({ min: undefined, max: undefined }),
          labels: {
            cmauzgw8p009p5kt61cvd2rhd: faker.random.word(),
          },
          managedFields: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              fieldsType: faker.random.word(),
              fieldsV1: {},
              manager: faker.random.word(),
              operation: faker.random.word(),
              subresource: faker.random.word(),
              time: faker.random.word(),
            }),
          ),
          name: faker.random.word(),
          namespace: faker.random.word(),
          ownerReferences: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              apiVersion: faker.random.word(),
              blockOwnerDeletion: faker.datatype.boolean(),
              controller: faker.datatype.boolean(),
              kind: faker.random.word(),
              name: faker.random.word(),
              uid: faker.random.word(),
            }),
          ),
          resourceVersion: faker.random.word(),
          selfLink: faker.random.word(),
          spec: {
            accessModes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.random.word(),
            ),
            dataSource: { apiGroup: faker.random.word(), kind: faker.random.word(), name: faker.random.word() },
            dataSourceRef: {
              apiGroup: faker.random.word(),
              kind: faker.random.word(),
              name: faker.random.word(),
              namespace: faker.random.word(),
            },
            resources: {
              claims: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
                name: faker.random.word(),
              })),
              limits: {
                cmauzgw8p009q5kt65epgc9um: { Format: faker.random.word() },
              },
              requests: {
                cmauzgw8p009r5kt65f7l32i8: { Format: faker.random.word() },
              },
            },
            selector: {
              matchExpressions: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  key: faker.random.word(),
                  operator: faker.random.word(),
                  values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
                    faker.random.word(),
                  ),
                }),
              ),
              matchLabels: {
                cmauzgw8p009s5kt6633523ud: faker.random.word(),
              },
            },
            storageClassName: faker.random.word(),
            volumeMode: faker.random.word(),
            volumeName: faker.random.word(),
          },
          uid: faker.random.word(),
        },
      },
      fc: {
        fsType: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        readOnly: faker.datatype.boolean(),
        targetWWNs: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        wwids: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
      },
      flexVolume: {
        driver: faker.random.word(),
        fsType: faker.random.word(),
        options: {
          cmauzgw8p009t5kt62h1x281j: faker.random.word(),
        },
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
      },
      flocker: { datasetName: faker.random.word(), datasetUUID: faker.random.word() },
      gcePersistentDisk: {
        fsType: faker.random.word(),
        partition: faker.datatype.number({ min: undefined, max: undefined }),
        pdName: faker.random.word(),
        readOnly: faker.datatype.boolean(),
      },
      gitRepo: { directory: faker.random.word(), repository: faker.random.word(), revision: faker.random.word() },
      glusterfs: { endpoints: faker.random.word(), path: faker.random.word(), readOnly: faker.datatype.boolean() },
      hostPath: { path: faker.random.word(), type: faker.random.word() },
      iscsi: {
        chapAuthDiscovery: faker.datatype.boolean(),
        chapAuthSession: faker.datatype.boolean(),
        fsType: faker.random.word(),
        initiatorName: faker.random.word(),
        iqn: faker.random.word(),
        iscsiInterface: faker.random.word(),
        lun: faker.datatype.number({ min: undefined, max: undefined }),
        portals: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        targetPortal: faker.random.word(),
      },
      name: faker.random.word(),
      nfs: { path: faker.random.word(), readOnly: faker.datatype.boolean(), server: faker.random.word() },
      persistentVolumeClaim: { claimName: faker.random.word(), readOnly: faker.datatype.boolean() },
      photonPersistentDisk: { fsType: faker.random.word(), pdID: faker.random.word() },
      portworxVolume: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        volumeID: faker.random.word(),
      },
      projected: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        sources: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          configMap: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          downwardAPI: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              fieldRef: { apiVersion: faker.random.word(), fieldPath: faker.random.word() },
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
              resourceFieldRef: {
                containerName: faker.random.word(),
                divisor: { Format: faker.random.word() },
                resource: faker.random.word(),
              },
            })),
          },
          secret: {
            items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
              key: faker.random.word(),
              mode: faker.datatype.number({ min: undefined, max: undefined }),
              path: faker.random.word(),
            })),
            name: faker.random.word(),
            optional: faker.datatype.boolean(),
          },
          serviceAccountToken: {
            audience: faker.random.word(),
            expirationSeconds: faker.datatype.number({ min: undefined, max: undefined }),
            path: faker.random.word(),
          },
        })),
      },
      quobyte: {
        group: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        registry: faker.random.word(),
        tenant: faker.random.word(),
        user: faker.random.word(),
        volume: faker.random.word(),
      },
      rbd: {
        fsType: faker.random.word(),
        image: faker.random.word(),
        keyring: faker.random.word(),
        monitors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
          faker.random.word(),
        ),
        pool: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        user: faker.random.word(),
      },
      scaleIO: {
        fsType: faker.random.word(),
        gateway: faker.random.word(),
        protectionDomain: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        sslEnabled: faker.datatype.boolean(),
        storageMode: faker.random.word(),
        storagePool: faker.random.word(),
        system: faker.random.word(),
        volumeName: faker.random.word(),
      },
      secret: {
        defaultMode: faker.datatype.number({ min: undefined, max: undefined }),
        items: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          key: faker.random.word(),
          mode: faker.datatype.number({ min: undefined, max: undefined }),
          path: faker.random.word(),
        })),
        optional: faker.datatype.boolean(),
        secretName: faker.random.word(),
      },
      storageos: {
        fsType: faker.random.word(),
        readOnly: faker.datatype.boolean(),
        secretRef: { name: faker.random.word() },
        volumeName: faker.random.word(),
        volumeNamespace: faker.random.word(),
      },
      vsphereVolume: {
        fsType: faker.random.word(),
        storagePolicyID: faker.random.word(),
        storagePolicyName: faker.random.word(),
        volumePath: faker.random.word(),
      },
    })),
  },
  templateType: faker.random.word(),
  timeChaos: {
    clockIds: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    containerNames: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.random.word(),
    ),
    duration: faker.random.word(),
    mode: faker.random.word(),
    remoteCluster: faker.random.word(),
    selector: {
      annotationSelectors: {
        cmauzgw8q009u5kt6dv0e0t4r: faker.random.word(),
      },
      expressionSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
        () => ({
          key: faker.random.word(),
          operator: faker.random.word(),
          values: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.random.word(),
          ),
        }),
      ),
      fieldSelectors: {
        cmauzgw8q009v5kt6ayqy8h52: faker.random.word(),
      },
      labelSelectors: {
        cmauzgw8q009w5kt69o0k8scv: faker.random.word(),
      },
      namespaces: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      nodeSelectors: {
        cmauzgw8q009x5kt6ah7o90jo: faker.random.word(),
      },
      nodes: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      podPhaseSelectors: Array.from({ length: faker.datatype.number({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
        faker.random.word(),
      ),
      pods: {
        cmauzgw8q009y5kt6bpab2sed: Array.from(
          { length: faker.datatype.number({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.random.word()),
      },
    },
    timeOffset: faker.random.word(),
    value: faker.random.word(),
  },
})

export const getPostWorkflowsValidateTaskHttpMock = () => faker.datatype.boolean()

export const getChaosMeshDashboardAPIMSW = () => [
  rest.delete('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesMock()))
  }),
  rest.get('*/archives', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesMock()))
  }),
  rest.delete('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesUidMock()))
  }),
  rest.get('*/archives/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesUidMock()))
  }),
  rest.delete('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesMock()))
  }),
  rest.get('*/archives/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesMock()))
  }),
  rest.delete('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesSchedulesUidMock()))
  }),
  rest.get('*/archives/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesSchedulesUidMock()))
  }),
  rest.delete('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsMock()))
  }),
  rest.get('*/archives/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsMock()))
  }),
  rest.delete('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteArchivesWorkflowsUidMock()))
  }),
  rest.get('*/archives/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetArchivesWorkflowsUidMock()))
  }),
  rest.get('*/common/annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonAnnotationsMock()))
  }),
  rest.get('*/common/chaos-available-namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonChaosAvailableNamespacesMock()))
  }),
  rest.get('*/common/config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonConfigMock()))
  }),
  rest.get('*/common/kinds', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonKindsMock()))
  }),
  rest.get('*/common/labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonLabelsMock()))
  }),
  rest.get('*/common/namespaces', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonNamespacesMock()))
  }),
  rest.get('*/common/physicalmachine-annotations', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineAnnotationsMock()))
  }),
  rest.get('*/common/physicalmachine-labels', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonPhysicalmachineLabelsMock()))
  }),
  rest.post('*/common/physicalmachines', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPhysicalmachinesMock()))
  }),
  rest.post('*/common/pods', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostCommonPodsMock()))
  }),
  rest.get('*/common/rbac-config', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetCommonRbacConfigMock()))
  }),
  rest.get('*/events', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsMock()))
  }),
  rest.get('*/events/:id', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsIdMock()))
  }),
  rest.get('*/events/workflow/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetEventsWorkflowUidMock()))
  }),
  rest.delete('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsMock()))
  }),
  rest.get('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsMock()))
  }),
  rest.post('*/experiments', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostExperimentsMock()))
  }),
  rest.delete('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteExperimentsUidMock()))
  }),
  rest.get('*/experiments/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsUidMock()))
  }),
  rest.put('*/experiments/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsPauseUidMock()))
  }),
  rest.put('*/experiments/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutExperimentsStartUidMock()))
  }),
  rest.get('*/experiments/state', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetExperimentsStateMock()))
  }),
  rest.delete('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesMock()))
  }),
  rest.get('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesMock()))
  }),
  rest.post('*/schedules', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostSchedulesMock()))
  }),
  rest.delete('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteSchedulesUidMock()))
  }),
  rest.get('*/schedules/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetSchedulesUidMock()))
  }),
  rest.put('*/schedules/pause/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesPauseUidMock()))
  }),
  rest.put('*/schedules/start/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutSchedulesStartUidMock()))
  }),
  rest.get('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksMock()))
  }),
  rest.post('*/templates/statuschecks', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostTemplatesStatuschecksMock()))
  }),
  rest.delete('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(
      ctx.delay(0),
      ctx.status(200, 'Mocked status'),
      ctx.json(getDeleteTemplatesStatuschecksStatuscheckMock()),
    )
  }),
  rest.get('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.put('*/templates/statuschecks/statuscheck', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutTemplatesStatuschecksStatuscheckMock()))
  }),
  rest.get('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsMock()))
  }),
  rest.post('*/workflows', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsMock()))
  }),
  rest.delete('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getDeleteWorkflowsUidMock()))
  }),
  rest.get('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getGetWorkflowsUidMock()))
  }),
  rest.put('*/workflows/:uid', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPutWorkflowsUidMock()))
  }),
  rest.post('*/workflows/parse-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsParseTaskHttpMock()))
  }),
  rest.post('*/workflows/render-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsRenderTaskHttpMock()))
  }),
  rest.post('*/workflows/validate-task/http', (_req, res, ctx) => {
    return res(ctx.delay(0), ctx.status(200, 'Mocked status'), ctx.json(getPostWorkflowsValidateTaskHttpMock()))
  }),
]
