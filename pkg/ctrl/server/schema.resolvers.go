package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"time"

	"github.com/chaos-mesh/chaos-mesh/api/v1alpha1"
	"github.com/chaos-mesh/chaos-mesh/pkg/ctrl/server/generated"
	"github.com/chaos-mesh/chaos-mesh/pkg/ctrl/server/model"
	podSelector "github.com/chaos-mesh/chaos-mesh/pkg/selector/pod"
	"k8s.io/api/core/v1"
	v11 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// Ino is the resolver for the ino field.
func (r *attrOverrideSpecResolver) Ino(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Ino == nil {
		return nil, nil
	}
	ino := (int)(*obj.Ino)
	return &ino, nil
}

// Size is the resolver for the size field.
func (r *attrOverrideSpecResolver) Size(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Size == nil {
		return nil, nil
	}
	size := (int)(*obj.Size)
	return &size, nil
}

// Blocks is the resolver for the blocks field.
func (r *attrOverrideSpecResolver) Blocks(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Blocks == nil {
		return nil, nil
	}
	blocks := (int)(*obj.Blocks)
	return &blocks, nil
}

// Kind is the resolver for the kind field.
func (r *attrOverrideSpecResolver) Kind(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*string, error) {
	if obj.Kind == nil {
		return nil, nil
	}
	kind := (string)(*obj.Kind)
	return &kind, nil
}

// Perm is the resolver for the perm field.
func (r *attrOverrideSpecResolver) Perm(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Perm == nil {
		return nil, nil
	}
	perm := (int)(*obj.Perm)
	return &perm, nil
}

// Nlink is the resolver for the nlink field.
func (r *attrOverrideSpecResolver) Nlink(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Nlink == nil {
		return nil, nil
	}
	nlink := (int)(*obj.Nlink)
	return &nlink, nil
}

// UID is the resolver for the uid field.
func (r *attrOverrideSpecResolver) UID(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.UID == nil {
		return nil, nil
	}
	uid := (int)(*obj.UID)
	return &uid, nil
}

// Gid is the resolver for the gid field.
func (r *attrOverrideSpecResolver) Gid(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.GID == nil {
		return nil, nil
	}
	gid := (int)(*obj.GID)
	return &gid, nil
}

// Rdev is the resolver for the rdev field.
func (r *attrOverrideSpecResolver) Rdev(ctx context.Context, obj *v1alpha1.AttrOverrideSpec) (*int, error) {
	if obj.Rdev == nil {
		return nil, nil
	}
	rdev := (int)(*obj.Rdev)
	return &rdev, nil
}

// Limit is the resolver for the limit field.
func (r *bandwidthSpecResolver) Limit(ctx context.Context, obj *v1alpha1.BandwidthSpec) (int, error) {
	return int(obj.Limit), nil
}

// Buffer is the resolver for the buffer field.
func (r *bandwidthSpecResolver) Buffer(ctx context.Context, obj *v1alpha1.BandwidthSpec) (int, error) {
	return int(obj.Buffer), nil
}

// Peakrate is the resolver for the peakrate field.
func (r *bandwidthSpecResolver) Peakrate(ctx context.Context, obj *v1alpha1.BandwidthSpec) (*int, error) {
	if obj.Peakrate == nil {
		return nil, nil
	}
	value := int(*obj.Peakrate)
	return &value, nil
}

// Minburst is the resolver for the minburst field.
func (r *bandwidthSpecResolver) Minburst(ctx context.Context, obj *v1alpha1.BandwidthSpec) (*int, error) {
	if obj.Minburst == nil {
		return nil, nil
	}
	value := int(*obj.Minburst)
	return &value, nil
}

// Type is the resolver for the type field.
func (r *chaosConditionResolver) Type(ctx context.Context, obj *v1alpha1.ChaosCondition) (string, error) {
	return string(obj.Type), nil
}

// Status is the resolver for the status field.
func (r *chaosConditionResolver) Status(ctx context.Context, obj *v1alpha1.ChaosCondition) (string, error) {
	return string(obj.Status), nil
}

// Port is the resolver for the port field.
func (r *cidrAndPortResolver) Port(ctx context.Context, obj *v1alpha1.CidrAndPort) (int, error) {
	return int(obj.Port), nil
}

// StartedAt is the resolver for the startedAt field.
func (r *containerStateRunningResolver) StartedAt(ctx context.Context, obj *v1.ContainerStateRunning) (*time.Time, error) {
	return &obj.StartedAt.Time, nil
}

// StartedAt is the resolver for the startedAt field.
func (r *containerStateTerminatedResolver) StartedAt(ctx context.Context, obj *v1.ContainerStateTerminated) (*time.Time, error) {
	return &obj.StartedAt.Time, nil
}

// FinishedAt is the resolver for the finishedAt field.
func (r *containerStateTerminatedResolver) FinishedAt(ctx context.Context, obj *v1.ContainerStateTerminated) (*time.Time, error) {
	return &obj.FinishedAt.Time, nil
}

// DesiredPhase is the resolver for the desiredPhase field.
func (r *experimentStatusResolver) DesiredPhase(ctx context.Context, obj *v1alpha1.ExperimentStatus) (string, error) {
	return string(obj.DesiredPhase), nil
}

// UID is the resolver for the uid field.
func (r *hTTPChaosResolver) UID(ctx context.Context, obj *v1alpha1.HTTPChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *hTTPChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.HTTPChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *hTTPChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.HTTPChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *hTTPChaosResolver) Labels(ctx context.Context, obj *v1alpha1.HTTPChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *hTTPChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.HTTPChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Podhttp is the resolver for the podhttp field.
func (r *hTTPChaosResolver) Podhttp(ctx context.Context, obj *v1alpha1.HTTPChaos) ([]*v1alpha1.PodHttpChaos, error) {
	podhttps := make([]*v1alpha1.PodHttpChaos, 0, len(obj.Status.Instances))
	for id := range obj.Status.Instances {
		podhttp := new(v1alpha1.PodHttpChaos)
		if err := r.Client.Get(ctx, parseNamespacedName(id), podhttp); err != nil {
			return nil, err
		}
		podhttps = append(podhttps, podhttp)
	}
	return podhttps, nil
}

// Mode is the resolver for the mode field.
func (r *hTTPChaosSpecResolver) Mode(ctx context.Context, obj *v1alpha1.HTTPChaosSpec) (string, error) {
	return string(obj.Mode), nil
}

// Target is the resolver for the target field.
func (r *hTTPChaosSpecResolver) Target(ctx context.Context, obj *v1alpha1.HTTPChaosSpec) (string, error) {
	return string(obj.Target), nil
}

// RequestHeaders is the resolver for the requestHeaders field.
func (r *hTTPChaosSpecResolver) RequestHeaders(ctx context.Context, obj *v1alpha1.HTTPChaosSpec) (map[string]any, error) {
	headers := make(map[string]interface{})
	for k, v := range obj.RequestHeaders {
		headers[k] = v
	}
	return headers, nil
}

// ResponseHeaders is the resolver for the responseHeaders field.
func (r *hTTPChaosSpecResolver) ResponseHeaders(ctx context.Context, obj *v1alpha1.HTTPChaosSpec) (map[string]any, error) {
	headers := make(map[string]interface{})
	for k, v := range obj.ResponseHeaders {
		headers[k] = v
	}
	return headers, nil
}

// Instances is the resolver for the instances field.
func (r *hTTPChaosStatusResolver) Instances(ctx context.Context, obj *v1alpha1.HTTPChaosStatus) (map[string]any, error) {
	instances := make(map[string]interface{})
	for k, v := range obj.Instances {
		instances[k] = v
	}
	return instances, nil
}

// UID is the resolver for the uid field.
func (r *iOChaosResolver) UID(ctx context.Context, obj *v1alpha1.IOChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *iOChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.IOChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *iOChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.IOChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *iOChaosResolver) Labels(ctx context.Context, obj *v1alpha1.IOChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *iOChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.IOChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Podios is the resolver for the podios field.
func (r *iOChaosResolver) Podios(ctx context.Context, obj *v1alpha1.IOChaos) ([]*v1alpha1.PodIOChaos, error) {
	podios := make([]*v1alpha1.PodIOChaos, 0, len(obj.Status.Instances))
	for id := range obj.Status.Instances {
		podio := new(v1alpha1.PodIOChaos)
		if err := r.Client.Get(ctx, parseNamespacedName(id), podio); err != nil {
			return nil, err
		}
		podios = append(podios, podio)
	}
	return podios, nil
}

// Type is the resolver for the type field.
func (r *iOChaosActionResolver) Type(ctx context.Context, obj *v1alpha1.IOChaosAction) (string, error) {
	return string(obj.Type), nil
}

// Methods is the resolver for the methods field.
func (r *iOChaosActionResolver) Methods(ctx context.Context, obj *v1alpha1.IOChaosAction) ([]string, error) {
	methods := make([]string, 0, len(obj.Methods))
	for k, v := range obj.Methods {
		methods[k] = string(v)
	}
	return methods, nil
}

// Ino is the resolver for the ino field.
func (r *iOChaosActionResolver) Ino(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.Ino == nil {
		return nil, nil
	}
	ino := (int64)(*obj.Ino)
	return &ino, nil
}

// Size is the resolver for the size field.
func (r *iOChaosActionResolver) Size(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.Size == nil {
		return nil, nil
	}
	size := (int64)(*obj.Size)
	return &size, nil
}

// Blocks is the resolver for the blocks field.
func (r *iOChaosActionResolver) Blocks(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.Blocks == nil {
		return nil, nil
	}
	blocks := (int64)(*obj.Blocks)
	return &blocks, nil
}

// Atime is the resolver for the atime field.
func (r *iOChaosActionResolver) Atime(ctx context.Context, obj *v1alpha1.IOChaosAction) (*v1alpha1.Timespec, error) {
	if obj.AttrOverrideSpec == nil {
		return nil, nil
	}
	return obj.Atime, nil
}

// Mtime is the resolver for the mtime field.
func (r *iOChaosActionResolver) Mtime(ctx context.Context, obj *v1alpha1.IOChaosAction) (*v1alpha1.Timespec, error) {
	if obj.AttrOverrideSpec == nil {
		return nil, nil
	}
	return obj.Mtime, nil
}

// Ctime is the resolver for the ctime field.
func (r *iOChaosActionResolver) Ctime(ctx context.Context, obj *v1alpha1.IOChaosAction) (*v1alpha1.Timespec, error) {
	if obj.AttrOverrideSpec == nil {
		return nil, nil
	}
	return obj.Ctime, nil
}

// Kind is the resolver for the kind field.
func (r *iOChaosActionResolver) Kind(ctx context.Context, obj *v1alpha1.IOChaosAction) (*string, error) {
	if obj.AttrOverrideSpec == nil || obj.Kind == nil {
		return nil, nil
	}
	kind := (string)(*obj.Kind)
	return &kind, nil
}

// Perm is the resolver for the perm field.
func (r *iOChaosActionResolver) Perm(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int, error) {
	if obj.AttrOverrideSpec == nil || obj.Perm == nil {
		return nil, nil
	}
	perm := (int)(*obj.Perm)
	return &perm, nil
}

// Nlink is the resolver for the nlink field.
func (r *iOChaosActionResolver) Nlink(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.Nlink == nil {
		return nil, nil
	}
	nlink := (int64)(*obj.Nlink)
	return &nlink, nil
}

// UID is the resolver for the uid field.
func (r *iOChaosActionResolver) UID(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.UID == nil {
		return nil, nil
	}
	uid := (int64)(*obj.UID)
	return &uid, nil
}

// Gid is the resolver for the gid field.
func (r *iOChaosActionResolver) Gid(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.GID == nil {
		return nil, nil
	}
	gid := (int64)(*obj.GID)
	return &gid, nil
}

// Rdev is the resolver for the rdev field.
func (r *iOChaosActionResolver) Rdev(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.AttrOverrideSpec == nil || obj.Rdev == nil {
		return nil, nil
	}
	rdev := (int64)(*obj.Rdev)
	return &rdev, nil
}

// Filling is the resolver for the filling field.
func (r *iOChaosActionResolver) Filling(ctx context.Context, obj *v1alpha1.IOChaosAction) (*string, error) {
	if obj.MistakeSpec == nil {
		return nil, nil
	}
	filling := string(obj.Filling)
	return &filling, nil
}

// MaxOccurrences is the resolver for the maxOccurrences field.
func (r *iOChaosActionResolver) MaxOccurrences(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.MistakeSpec == nil {
		return nil, nil
	}
	return &obj.MaxOccurrences, nil
}

// MaxLength is the resolver for the maxLength field.
func (r *iOChaosActionResolver) MaxLength(ctx context.Context, obj *v1alpha1.IOChaosAction) (*int64, error) {
	if obj.MistakeSpec == nil {
		return nil, nil
	}
	return &obj.MaxLength, nil
}

// Mode is the resolver for the mode field.
func (r *iOChaosSpecResolver) Mode(ctx context.Context, obj *v1alpha1.IOChaosSpec) (string, error) {
	return string(obj.Mode), nil
}

// Action is the resolver for the action field.
func (r *iOChaosSpecResolver) Action(ctx context.Context, obj *v1alpha1.IOChaosSpec) (string, error) {
	return string(obj.Action), nil
}

// Errno is the resolver for the errno field.
func (r *iOChaosSpecResolver) Errno(ctx context.Context, obj *v1alpha1.IOChaosSpec) (*int, error) {
	errno := int(obj.Errno)
	return &errno, nil
}

// Methods is the resolver for the methods field.
func (r *iOChaosSpecResolver) Methods(ctx context.Context, obj *v1alpha1.IOChaosSpec) ([]string, error) {
	methods := make([]string, 0, len(obj.Methods))
	for _, method := range obj.Methods {
		methods = append(methods, string(method))
	}
	return methods, nil
}

// Instances is the resolver for the instances field.
func (r *iOChaosStatusResolver) Instances(ctx context.Context, obj *v1alpha1.IOChaosStatus) (map[string]any, error) {
	instances := make(map[string]interface{})
	for k, v := range obj.Instances {
		instances[k] = v
	}
	return instances, nil
}

// Errno is the resolver for the errno field.
func (r *ioFaultResolver) Errno(ctx context.Context, obj *v1alpha1.IoFault) (int, error) {
	return int(obj.Errno), nil
}

// Component is the resolver for the component field.
func (r *loggerResolver) Component(ctx context.Context, ns string, component model.Component) (<-chan string, error) {
	var list v1.PodList
	if err := r.Client.List(ctx, &list, client.MatchingLabels(componentLabels(component)), client.InNamespace(ns)); err != nil {
		return nil, err
	}

	if len(list.Items) == 0 {
		return nil, fmt.Errorf("instance of %s not found", component)
	}

	return r.Pod(ctx, list.Items[0].Namespace, list.Items[0].Name)
}

// Pod is the resolver for the pod field.
func (r *loggerResolver) Pod(ctx context.Context, ns string, name string) (<-chan string, error) {
	logs, err := r.Clientset.CoreV1().Pods(ns).GetLogs(name, &v1.PodLogOptions{Follow: true}).Stream(ctx)
	if err != nil {
		return nil, err
	}
	logChan := make(chan string)
	go func() {
		defer logs.Close()
		reader := bufio.NewReader(logs)
		for {
			line, err := reader.ReadString('\n')
			if err != nil {
				r.Log.Error(err, fmt.Sprintf("fail to read log of pod(%s/%s)", ns, name))
				break
			}
			select {
			case logChan <- string(line):
				continue
			case <-time.NewTimer(time.Minute).C:
				r.Log.Info(fmt.Sprintf("client has not read log of pod(%s/%s) for 1m, close channel", ns, name))
				return
			}
		}
	}()
	return logChan, nil
}

// Filling is the resolver for the filling field.
func (r *mistakeSpecResolver) Filling(ctx context.Context, obj *v1alpha1.MistakeSpec) (*string, error) {
	filling := string(obj.Filling)
	return &filling, nil
}

// KillProcesses is the resolver for the killProcesses field.
func (r *mutablePodResolver) KillProcesses(ctx context.Context, obj *model.MutablePod, pids []string) ([]*model.KillProcessResult, error) {
	return r.Resolver.killProcess(ctx, obj.Pod, pids)
}

// CleanTcs is the resolver for the cleanTcs field.
func (r *mutablePodResolver) CleanTcs(ctx context.Context, obj *model.MutablePod, devices []string) ([]string, error) {
	return r.Resolver.cleanTcs(ctx, obj.Pod, devices)
}

// CleanIptables is the resolver for the cleanIptables field.
func (r *mutablePodResolver) CleanIptables(ctx context.Context, obj *model.MutablePod, chains []string) ([]string, error) {
	return r.Resolver.cleanIptables(ctx, obj.Pod, chains)
}

// Pod is the resolver for the pod field.
func (r *mutationResolver) Pod(ctx context.Context, ns string, name string) (*model.MutablePod, error) {
	key := types.NamespacedName{Namespace: ns, Name: name}
	pod := new(v1.Pod)
	if err := r.Client.Get(ctx, key, pod); err != nil {
		return nil, err
	}
	return &model.MutablePod{Pod: pod}, nil
}

// Component is the resolver for the component field.
func (r *namespaceResolver) Component(ctx context.Context, obj *model.Namespace, component model.Component) ([]*v1.Pod, error) {
	var list v1.PodList
	var pods []*v1.Pod
	if err := r.Client.List(ctx, &list, client.MatchingLabels(componentLabels(component)), client.InNamespace(obj.Ns)); err != nil {
		return nil, err
	}
	for i := range list.Items {
		pods = append(pods, &list.Items[i])
	}
	return pods, nil
}

// Pod is the resolver for the pod field.
func (r *namespaceResolver) Pod(ctx context.Context, obj *model.Namespace, name *string) ([]*v1.Pod, error) {
	if name == nil {
		var podList v1.PodList
		var pods []*v1.Pod
		if err := r.Client.List(ctx, &podList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range podList.Items {
			pods = append(pods, &podList.Items[i])
		}

		return pods, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	pod := new(v1.Pod)
	if err := r.Client.Get(ctx, key, pod); err != nil {
		return nil, err
	}
	return []*v1.Pod{pod}, nil
}

// Stresschaos is the resolver for the stresschaos field.
func (r *namespaceResolver) Stresschaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.StressChaos, error) {
	if name == nil {
		var stressList v1alpha1.StressChaosList
		var stresses []*v1alpha1.StressChaos
		if err := r.Client.List(ctx, &stressList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range stressList.Items {
			stresses = append(stresses, &stressList.Items[i])
		}

		return stresses, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	stress := new(v1alpha1.StressChaos)
	if err := r.Client.Get(ctx, key, stress); err != nil {
		return nil, err
	}
	return []*v1alpha1.StressChaos{stress}, nil
}

// Iochaos is the resolver for the iochaos field.
func (r *namespaceResolver) Iochaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.IOChaos, error) {
	if name == nil {
		var ioList v1alpha1.IOChaosList
		var ios []*v1alpha1.IOChaos
		if err := r.Client.List(ctx, &ioList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range ioList.Items {
			ios = append(ios, &ioList.Items[i])
		}

		return ios, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	io := new(v1alpha1.IOChaos)
	if err := r.Client.Get(ctx, key, io); err != nil {
		return nil, err
	}
	return []*v1alpha1.IOChaos{io}, nil
}

// Podiochaos is the resolver for the podiochaos field.
func (r *namespaceResolver) Podiochaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.PodIOChaos, error) {
	if name == nil {
		var ioList v1alpha1.PodIOChaosList
		var ios []*v1alpha1.PodIOChaos
		if err := r.Client.List(ctx, &ioList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range ioList.Items {
			ios = append(ios, &ioList.Items[i])
		}

		return ios, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	io := new(v1alpha1.PodIOChaos)
	if err := r.Client.Get(ctx, key, io); err != nil {
		return nil, err
	}

	return []*v1alpha1.PodIOChaos{io}, nil
}

// Httpchaos is the resolver for the httpchaos field.
func (r *namespaceResolver) Httpchaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.HTTPChaos, error) {
	if name == nil {
		var httpList v1alpha1.HTTPChaosList
		var https []*v1alpha1.HTTPChaos
		if err := r.Client.List(ctx, &httpList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range httpList.Items {
			https = append(https, &httpList.Items[i])
		}

		return https, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	http := new(v1alpha1.HTTPChaos)
	if err := r.Client.Get(ctx, key, http); err != nil {
		return nil, err
	}
	return []*v1alpha1.HTTPChaos{http}, nil
}

// Podhttpchaos is the resolver for the podhttpchaos field.
func (r *namespaceResolver) Podhttpchaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.PodHttpChaos, error) {
	if name == nil {
		var httpList v1alpha1.PodHttpChaosList
		var https []*v1alpha1.PodHttpChaos
		if err := r.Client.List(ctx, &httpList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range httpList.Items {
			https = append(https, &httpList.Items[i])
		}

		return https, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	http := new(v1alpha1.PodHttpChaos)
	if err := r.Client.Get(ctx, key, http); err != nil {
		return nil, err
	}
	return []*v1alpha1.PodHttpChaos{http}, nil
}

// Networkchaos is the resolver for the networkchaos field.
func (r *namespaceResolver) Networkchaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.NetworkChaos, error) {
	if name == nil {
		var networkList v1alpha1.NetworkChaosList
		var networks []*v1alpha1.NetworkChaos
		if err := r.Client.List(ctx, &networkList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range networkList.Items {
			networks = append(networks, &networkList.Items[i])
		}

		return networks, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	network := new(v1alpha1.NetworkChaos)
	if err := r.Client.Get(ctx, key, network); err != nil {
		return nil, err
	}
	return []*v1alpha1.NetworkChaos{network}, nil
}

// Podnetworkchaos is the resolver for the podnetworkchaos field.
func (r *namespaceResolver) Podnetworkchaos(ctx context.Context, obj *model.Namespace, name *string) ([]*v1alpha1.PodNetworkChaos, error) {
	if name == nil {
		var networkList v1alpha1.PodNetworkChaosList
		var networks []*v1alpha1.PodNetworkChaos
		if err := r.Client.List(ctx, &networkList, &client.ListOptions{Namespace: obj.Ns}); err != nil {
			return nil, err
		}

		for i := range networkList.Items {
			networks = append(networks, &networkList.Items[i])
		}

		return networks, nil
	}

	key := types.NamespacedName{Namespace: obj.Ns, Name: *name}
	network := new(v1alpha1.PodNetworkChaos)
	if err := r.Client.Get(ctx, key, network); err != nil {
		return nil, err
	}
	return []*v1alpha1.PodNetworkChaos{network}, nil
}

// UID is the resolver for the uid field.
func (r *networkChaosResolver) UID(ctx context.Context, obj *v1alpha1.NetworkChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *networkChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.NetworkChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *networkChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.NetworkChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *networkChaosResolver) Labels(ctx context.Context, obj *v1alpha1.NetworkChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *networkChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.NetworkChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Podnetwork is the resolver for the podnetwork field.
func (r *networkChaosResolver) Podnetwork(ctx context.Context, obj *v1alpha1.NetworkChaos) ([]*v1alpha1.PodNetworkChaos, error) {
	podnetworks := make([]*v1alpha1.PodNetworkChaos, 0, len(obj.Status.Instances))
	for id := range obj.Status.Instances {
		podnetwork := new(v1alpha1.PodNetworkChaos)
		if err := r.Client.Get(ctx, parseNamespacedName(id), podnetwork); err != nil {
			return nil, err
		}
		podnetworks = append(podnetworks, podnetwork)
	}
	return podnetworks, nil
}

// UID is the resolver for the uid field.
func (r *ownerReferenceResolver) UID(ctx context.Context, obj *v11.OwnerReference) (string, error) {
	return string(obj.UID), nil
}

// UID is the resolver for the uid field.
func (r *podResolver) UID(ctx context.Context, obj *v1.Pod) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *podResolver) CreationTimestamp(ctx context.Context, obj *v1.Pod) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *podResolver) DeletionTimestamp(ctx context.Context, obj *v1.Pod) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *podResolver) Labels(ctx context.Context, obj *v1.Pod) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *podResolver) Annotations(ctx context.Context, obj *v1.Pod) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Logs is the resolver for the logs field.
func (r *podResolver) Logs(ctx context.Context, obj *v1.Pod) (string, error) {
	logs, err := r.Clientset.CoreV1().Pods(obj.Namespace).GetLogs(obj.Name, &v1.PodLogOptions{}).Stream(ctx)
	if err != nil {
		return "", err
	}
	defer logs.Close()
	data, err := io.ReadAll(logs)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// Daemon is the resolver for the daemon field.
func (r *podResolver) Daemon(ctx context.Context, obj *v1.Pod) (*v1.Pod, error) {
	daemons, err := getDaemonMap(ctx, r.Client)
	if err != nil {
		return nil, err
	}

	daemon, exist := daemons[obj.Spec.NodeName]
	if !exist {
		return nil, fmt.Errorf("daemon of pod(%s/%s) not found", obj.Namespace, obj.Name)
	}
	return &daemon, nil
}

// Processes is the resolver for the processes field.
func (r *podResolver) Processes(ctx context.Context, obj *v1.Pod) ([]*model.Process, error) {
	return r.GetPidFromPS(ctx, obj)
}

// Mounts is the resolver for the mounts field.
func (r *podResolver) Mounts(ctx context.Context, obj *v1.Pod) ([]string, error) {
	return r.GetMounts(ctx, obj)
}

// Ipset is the resolver for the ipset field.
func (r *podResolver) Ipset(ctx context.Context, obj *v1.Pod) (string, error) {
	return r.GetIpset(ctx, obj)
}

// TcQdisc is the resolver for the tcQdisc field.
func (r *podResolver) TcQdisc(ctx context.Context, obj *v1.Pod) ([]string, error) {
	return r.GetTcQdisc(ctx, obj)
}

// Iptables is the resolver for the iptables field.
func (r *podResolver) Iptables(ctx context.Context, obj *v1.Pod) ([]string, error) {
	return r.GetIptables(ctx, obj)
}

// Type is the resolver for the type field.
func (r *podConditionResolver) Type(ctx context.Context, obj *v1.PodCondition) (string, error) {
	return string(obj.Type), nil
}

// Status is the resolver for the status field.
func (r *podConditionResolver) Status(ctx context.Context, obj *v1.PodCondition) (string, error) {
	return string(obj.Status), nil
}

// LastProbeTime is the resolver for the lastProbeTime field.
func (r *podConditionResolver) LastProbeTime(ctx context.Context, obj *v1.PodCondition) (*time.Time, error) {
	return &obj.LastProbeTime.Time, nil
}

// LastTransitionTime is the resolver for the lastTransitionTime field.
func (r *podConditionResolver) LastTransitionTime(ctx context.Context, obj *v1.PodCondition) (*time.Time, error) {
	return &obj.LastTransitionTime.Time, nil
}

// UID is the resolver for the uid field.
func (r *podHTTPChaosResolver) UID(ctx context.Context, obj *v1alpha1.PodHttpChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *podHTTPChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.PodHttpChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *podHTTPChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.PodHttpChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *podHTTPChaosResolver) Labels(ctx context.Context, obj *v1alpha1.PodHttpChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *podHTTPChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.PodHttpChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Pod is the resolver for the pod field.
func (r *podHTTPChaosResolver) Pod(ctx context.Context, obj *v1alpha1.PodHttpChaos) (*v1.Pod, error) {
	pod := new(v1.Pod)
	if err := r.Client.Get(ctx, types.NamespacedName{Namespace: obj.Namespace, Name: obj.Name}, pod); err != nil {
		return nil, err
	}
	return pod, nil
}

// Body is the resolver for the body field.
func (r *podHttpChaosReplaceActionsResolver) Body(ctx context.Context, obj *v1alpha1.PodHttpChaosReplaceActions) (*string, error) {
	data, err := json.Marshal(obj.Body)
	if err != nil {
		return nil, err
	}

	body := string(data)
	return &body, nil
}

// Queries is the resolver for the queries field.
func (r *podHttpChaosReplaceActionsResolver) Queries(ctx context.Context, obj *v1alpha1.PodHttpChaosReplaceActions) (map[string]any, error) {
	queries := make(map[string]interface{})
	for k, v := range obj.Queries {
		queries[k] = v
	}
	return queries, nil
}

// Headers is the resolver for the headers field.
func (r *podHttpChaosReplaceActionsResolver) Headers(ctx context.Context, obj *v1alpha1.PodHttpChaosReplaceActions) (map[string]any, error) {
	headers := make(map[string]interface{})
	for k, v := range obj.Headers {
		headers[k] = v
	}
	return headers, nil
}

// Target is the resolver for the target field.
func (r *podHttpChaosRuleResolver) Target(ctx context.Context, obj *v1alpha1.PodHttpChaosRule) (string, error) {
	return string(obj.Target), nil
}

// RequestHeaders is the resolver for the requestHeaders field.
func (r *podHttpChaosSelectorResolver) RequestHeaders(ctx context.Context, obj *v1alpha1.PodHttpChaosSelector) (map[string]any, error) {
	headers := make(map[string]interface{})
	for k, v := range obj.RequestHeaders {
		headers[k] = v
	}
	return headers, nil
}

// ResponseHeaders is the resolver for the responseHeaders field.
func (r *podHttpChaosSelectorResolver) ResponseHeaders(ctx context.Context, obj *v1alpha1.PodHttpChaosSelector) (map[string]any, error) {
	headers := make(map[string]interface{})
	for k, v := range obj.ResponseHeaders {
		headers[k] = v
	}
	return headers, nil
}

// UID is the resolver for the uid field.
func (r *podIOChaosResolver) UID(ctx context.Context, obj *v1alpha1.PodIOChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *podIOChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.PodIOChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *podIOChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.PodIOChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *podIOChaosResolver) Labels(ctx context.Context, obj *v1alpha1.PodIOChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *podIOChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.PodIOChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Pod is the resolver for the pod field.
func (r *podIOChaosResolver) Pod(ctx context.Context, obj *v1alpha1.PodIOChaos) (*v1.Pod, error) {
	pod := new(v1.Pod)
	key := types.NamespacedName{Namespace: obj.Namespace, Name: obj.Name}
	if err := r.Client.Get(ctx, key, pod); err != nil {
		return nil, err
	}
	return pod, nil
}

// Ios is the resolver for the ios field.
func (r *podIOChaosResolver) Ios(ctx context.Context, obj *v1alpha1.PodIOChaos) ([]*v1alpha1.IOChaos, error) {
	ioNames := make(map[string]bool)
	for _, action := range obj.Spec.Actions {
		ioNames[action.Source] = true
	}

	ios := make([]*v1alpha1.IOChaos, 0, len(ioNames))
	for name := range ioNames {
		namespaced := parseNamespacedName(name)
		io := new(v1alpha1.IOChaos)
		if err := r.Client.Get(ctx, namespaced, io); err != nil {
			return nil, err
		}
		ios = append(ios, io)
	}
	return ios, nil
}

// UID is the resolver for the uid field.
func (r *podNetworkChaosResolver) UID(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *podNetworkChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *podNetworkChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *podNetworkChaosResolver) Labels(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *podNetworkChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Pod is the resolver for the pod field.
func (r *podNetworkChaosResolver) Pod(ctx context.Context, obj *v1alpha1.PodNetworkChaos) (*v1.Pod, error) {
	pod := new(v1.Pod)
	if err := r.Client.Get(ctx, types.NamespacedName{Namespace: obj.Namespace, Name: obj.Name}, pod); err != nil {
		return nil, err
	}
	return pod, nil
}

// Pods is the resolver for the pods field.
func (r *podSelectorSpecResolver) Pods(ctx context.Context, obj *v1alpha1.PodSelectorSpec) (map[string]any, error) {
	pods := make(map[string]interface{})
	for k, v := range obj.Pods {
		pods[k] = v
	}
	return pods, nil
}

// NodeSelectors is the resolver for the nodeSelectors field.
func (r *podSelectorSpecResolver) NodeSelectors(ctx context.Context, obj *v1alpha1.PodSelectorSpec) (map[string]any, error) {
	selectors := make(map[string]interface{})
	for k, v := range obj.NodeSelectors {
		selectors[k] = v
	}
	return selectors, nil
}

// FieldSelectors is the resolver for the fieldSelectors field.
func (r *podSelectorSpecResolver) FieldSelectors(ctx context.Context, obj *v1alpha1.PodSelectorSpec) (map[string]any, error) {
	selectors := make(map[string]interface{})
	for k, v := range obj.FieldSelectors {
		selectors[k] = v
	}
	return selectors, nil
}

// LabelSelectors is the resolver for the labelSelectors field.
func (r *podSelectorSpecResolver) LabelSelectors(ctx context.Context, obj *v1alpha1.PodSelectorSpec) (map[string]any, error) {
	selectors := make(map[string]interface{})
	for k, v := range obj.LabelSelectors {
		selectors[k] = v
	}
	return selectors, nil
}

// AnnotationSelectors is the resolver for the annotationSelectors field.
func (r *podSelectorSpecResolver) AnnotationSelectors(ctx context.Context, obj *v1alpha1.PodSelectorSpec) (map[string]any, error) {
	selectors := make(map[string]interface{})
	for k, v := range obj.AnnotationSelectors {
		selectors[k] = v
	}
	return selectors, nil
}

// Phase is the resolver for the phase field.
func (r *podStatusResolver) Phase(ctx context.Context, obj *v1.PodStatus) (string, error) {
	return string(obj.Phase), nil
}

// StartTime is the resolver for the startTime field.
func (r *podStatusResolver) StartTime(ctx context.Context, obj *v1.PodStatus) (*time.Time, error) {
	return &obj.StartTime.Time, nil
}

// QosClass is the resolver for the qosClass field.
func (r *podStatusResolver) QosClass(ctx context.Context, obj *v1.PodStatus) (string, error) {
	return string(obj.QOSClass), nil
}

// Cgroups is the resolver for the cgroups field.
func (r *podStressChaosResolver) Cgroups(ctx context.Context, obj *model.PodStressChaos) (*model.Cgroups, error) {
	return r.GetCgroups(ctx, obj)
}

// ProcessStress is the resolver for the processStress field.
func (r *podStressChaosResolver) ProcessStress(ctx context.Context, obj *model.PodStressChaos) ([]*model.ProcessStress, error) {
	processes, err := r.Pod().Processes(ctx, obj.Pod)
	if err != nil {
		return nil, err
	}

	var processStress []*model.ProcessStress
	for _, process := range processes {
		cgroup, err := r.GetCgroup(ctx, obj.Pod, process.Pid)
		if err != nil {
			r.Log.Error(err, "get cgroup for process", "pid", process.Pid)
			// ignore this process
			continue
		}

		processStress = append(processStress, &model.ProcessStress{
			Process: process,
			Cgroup:  cgroup,
		})
	}
	return processStress, nil
}

// Fds is the resolver for the fds field.
func (r *processResolver) Fds(ctx context.Context, obj *model.Process) ([]*model.Fd, error) {
	return r.GetFdsOfProcess(ctx, obj), nil
}

// Namespace is the resolver for the namespace field.
func (r *queryResolver) Namespace(ctx context.Context, ns *string) ([]*model.Namespace, error) {
	if ns == nil {
		var nsList v1.NamespaceList
		var namespaces []*model.Namespace
		if err := r.Client.List(ctx, &nsList); err != nil {
			return nil, err
		}

		for _, ns := range nsList.Items {
			namespaces = append(namespaces, &model.Namespace{Ns: ns.Name})
		}

		return namespaces, nil
	}
	return []*model.Namespace{{Ns: *ns}}, nil
}

// Pods is the resolver for the pods field.
func (r *queryResolver) Pods(ctx context.Context, selector model.PodSelectorInput) ([]*v1.Pod, error) {
	spec := v1alpha1.PodSelectorSpec{
		Pods:              map[string][]string{},
		NodeSelectors:     map[string]string{},
		Nodes:             selector.Nodes,
		PodPhaseSelectors: selector.PodPhaseSelectors,
		GenericSelectorSpec: v1alpha1.GenericSelectorSpec{
			Namespaces:          selector.Namespaces,
			FieldSelectors:      map[string]string{},
			LabelSelectors:      map[string]string{},
			AnnotationSelectors: map[string]string{},
		},
	}

	for ns, p := range selector.Pods {
		if pod, ok := p.(string); ok {
			spec.Pods[ns] = []string{pod}
		}

		if pods, ok := p.([]string); ok {
			spec.Pods[ns] = pods
		}
	}

	for k, s := range selector.NodeSelectors {
		if selector, ok := s.(string); ok {
			spec.NodeSelectors[k] = selector
		}
	}

	for k, s := range selector.FieldSelectors {
		if selector, ok := s.(string); ok {
			spec.FieldSelectors[k] = selector
		}
	}

	for k, s := range selector.LabelSelectors {
		if selector, ok := s.(string); ok {
			spec.LabelSelectors[k] = selector
		}
	}

	for k, s := range selector.AnnotationSelectors {
		if selector, ok := s.(string); ok {
			spec.AnnotationSelectors[k] = selector
		}
	}

	selectImpl := podSelector.New(podSelector.Params{
		Client: r.Client,
		Reader: r.Client,
	})
	pods, err := selectImpl.Select(ctx, &v1alpha1.PodSelector{Selector: spec, Mode: v1alpha1.AllMode})
	if err != nil {
		if errors.Is(err, podSelector.ErrNoPodSelected) {
			return nil, nil
		}
		return nil, err
	}
	var list []*v1.Pod
	for _, pod := range pods {
		p := pod
		list = append(list, &p.Pod)
	}
	return list, nil
}

// IPSetType is the resolver for the ipSetType field.
func (r *rawIPSetResolver) IPSetType(ctx context.Context, obj *v1alpha1.RawIPSet) (string, error) {
	return string(obj.IPSetType), nil
}

// Direction is the resolver for the direction field.
func (r *rawIptablesResolver) Direction(ctx context.Context, obj *v1alpha1.RawIptables) (string, error) {
	return string(obj.Direction), nil
}

// Type is the resolver for the type field.
func (r *rawTrafficControlResolver) Type(ctx context.Context, obj *v1alpha1.RawTrafficControl) (string, error) {
	return string(obj.Type), nil
}

// Phase is the resolver for the phase field.
func (r *recordResolver) Phase(ctx context.Context, obj *v1alpha1.Record) (string, error) {
	return string(obj.Phase), nil
}

// UID is the resolver for the uid field.
func (r *stressChaosResolver) UID(ctx context.Context, obj *v1alpha1.StressChaos) (string, error) {
	return string(obj.UID), nil
}

// CreationTimestamp is the resolver for the creationTimestamp field.
func (r *stressChaosResolver) CreationTimestamp(ctx context.Context, obj *v1alpha1.StressChaos) (*time.Time, error) {
	return &obj.CreationTimestamp.Time, nil
}

// DeletionTimestamp is the resolver for the deletionTimestamp field.
func (r *stressChaosResolver) DeletionTimestamp(ctx context.Context, obj *v1alpha1.StressChaos) (*time.Time, error) {
	return &obj.DeletionTimestamp.Time, nil
}

// Labels is the resolver for the labels field.
func (r *stressChaosResolver) Labels(ctx context.Context, obj *v1alpha1.StressChaos) (map[string]any, error) {
	labels := make(map[string]interface{})
	for k, v := range obj.Labels {
		labels[k] = v
	}
	return labels, nil
}

// Annotations is the resolver for the annotations field.
func (r *stressChaosResolver) Annotations(ctx context.Context, obj *v1alpha1.StressChaos) (map[string]any, error) {
	annotations := make(map[string]interface{})
	for k, v := range obj.Annotations {
		annotations[k] = v
	}
	return annotations, nil
}

// Podstress is the resolver for the podstress field.
func (r *stressChaosResolver) Podstress(ctx context.Context, obj *v1alpha1.StressChaos) ([]*model.PodStressChaos, error) {
	pods, _, err := GetPods(ctx, obj.Status.ChaosStatus, obj.Spec.Selector, r.Client)
	if err != nil {
		return nil, err
	}

	var podStress []*model.PodStressChaos
	for _, pod := range pods {
		p := pod
		podStress = append(podStress, &model.PodStressChaos{
			StressChaos: obj,
			Pod:         &p,
		})
	}
	return podStress, nil
}

// Mode is the resolver for the mode field.
func (r *stressChaosSpecResolver) Mode(ctx context.Context, obj *v1alpha1.StressChaosSpec) (string, error) {
	return string(obj.Mode), nil
}

// Instances is the resolver for the instances field.
func (r *stressChaosStatusResolver) Instances(ctx context.Context, obj *v1alpha1.StressChaosStatus) (map[string]any, error) {
	instances := make(map[string]interface{})
	for k, v := range obj.Instances {
		instances[k] = v
	}
	return instances, nil
}

// AttrOverrideSpec returns generated.AttrOverrideSpecResolver implementation.
func (r *Resolver) AttrOverrideSpec() generated.AttrOverrideSpecResolver {
	return &attrOverrideSpecResolver{r}
}

// BandwidthSpec returns generated.BandwidthSpecResolver implementation.
func (r *Resolver) BandwidthSpec() generated.BandwidthSpecResolver { return &bandwidthSpecResolver{r} }

// ChaosCondition returns generated.ChaosConditionResolver implementation.
func (r *Resolver) ChaosCondition() generated.ChaosConditionResolver {
	return &chaosConditionResolver{r}
}

// CidrAndPort returns generated.CidrAndPortResolver implementation.
func (r *Resolver) CidrAndPort() generated.CidrAndPortResolver { return &cidrAndPortResolver{r} }

// ContainerStateRunning returns generated.ContainerStateRunningResolver implementation.
func (r *Resolver) ContainerStateRunning() generated.ContainerStateRunningResolver {
	return &containerStateRunningResolver{r}
}

// ContainerStateTerminated returns generated.ContainerStateTerminatedResolver implementation.
func (r *Resolver) ContainerStateTerminated() generated.ContainerStateTerminatedResolver {
	return &containerStateTerminatedResolver{r}
}

// ExperimentStatus returns generated.ExperimentStatusResolver implementation.
func (r *Resolver) ExperimentStatus() generated.ExperimentStatusResolver {
	return &experimentStatusResolver{r}
}

// HTTPChaos returns generated.HTTPChaosResolver implementation.
func (r *Resolver) HTTPChaos() generated.HTTPChaosResolver { return &hTTPChaosResolver{r} }

// HTTPChaosSpec returns generated.HTTPChaosSpecResolver implementation.
func (r *Resolver) HTTPChaosSpec() generated.HTTPChaosSpecResolver { return &hTTPChaosSpecResolver{r} }

// HTTPChaosStatus returns generated.HTTPChaosStatusResolver implementation.
func (r *Resolver) HTTPChaosStatus() generated.HTTPChaosStatusResolver {
	return &hTTPChaosStatusResolver{r}
}

// IOChaos returns generated.IOChaosResolver implementation.
func (r *Resolver) IOChaos() generated.IOChaosResolver { return &iOChaosResolver{r} }

// IOChaosAction returns generated.IOChaosActionResolver implementation.
func (r *Resolver) IOChaosAction() generated.IOChaosActionResolver { return &iOChaosActionResolver{r} }

// IOChaosSpec returns generated.IOChaosSpecResolver implementation.
func (r *Resolver) IOChaosSpec() generated.IOChaosSpecResolver { return &iOChaosSpecResolver{r} }

// IOChaosStatus returns generated.IOChaosStatusResolver implementation.
func (r *Resolver) IOChaosStatus() generated.IOChaosStatusResolver { return &iOChaosStatusResolver{r} }

// IoFault returns generated.IoFaultResolver implementation.
func (r *Resolver) IoFault() generated.IoFaultResolver { return &ioFaultResolver{r} }

// Logger returns generated.LoggerResolver implementation.
func (r *Resolver) Logger() generated.LoggerResolver { return &loggerResolver{r} }

// MistakeSpec returns generated.MistakeSpecResolver implementation.
func (r *Resolver) MistakeSpec() generated.MistakeSpecResolver { return &mistakeSpecResolver{r} }

// MutablePod returns generated.MutablePodResolver implementation.
func (r *Resolver) MutablePod() generated.MutablePodResolver { return &mutablePodResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Namespace returns generated.NamespaceResolver implementation.
func (r *Resolver) Namespace() generated.NamespaceResolver { return &namespaceResolver{r} }

// NetworkChaos returns generated.NetworkChaosResolver implementation.
func (r *Resolver) NetworkChaos() generated.NetworkChaosResolver { return &networkChaosResolver{r} }

// OwnerReference returns generated.OwnerReferenceResolver implementation.
func (r *Resolver) OwnerReference() generated.OwnerReferenceResolver {
	return &ownerReferenceResolver{r}
}

// Pod returns generated.PodResolver implementation.
func (r *Resolver) Pod() generated.PodResolver { return &podResolver{r} }

// PodCondition returns generated.PodConditionResolver implementation.
func (r *Resolver) PodCondition() generated.PodConditionResolver { return &podConditionResolver{r} }

// PodHTTPChaos returns generated.PodHTTPChaosResolver implementation.
func (r *Resolver) PodHTTPChaos() generated.PodHTTPChaosResolver { return &podHTTPChaosResolver{r} }

// PodHttpChaosReplaceActions returns generated.PodHttpChaosReplaceActionsResolver implementation.
func (r *Resolver) PodHttpChaosReplaceActions() generated.PodHttpChaosReplaceActionsResolver {
	return &podHttpChaosReplaceActionsResolver{r}
}

// PodHttpChaosRule returns generated.PodHttpChaosRuleResolver implementation.
func (r *Resolver) PodHttpChaosRule() generated.PodHttpChaosRuleResolver {
	return &podHttpChaosRuleResolver{r}
}

// PodHttpChaosSelector returns generated.PodHttpChaosSelectorResolver implementation.
func (r *Resolver) PodHttpChaosSelector() generated.PodHttpChaosSelectorResolver {
	return &podHttpChaosSelectorResolver{r}
}

// PodIOChaos returns generated.PodIOChaosResolver implementation.
func (r *Resolver) PodIOChaos() generated.PodIOChaosResolver { return &podIOChaosResolver{r} }

// PodNetworkChaos returns generated.PodNetworkChaosResolver implementation.
func (r *Resolver) PodNetworkChaos() generated.PodNetworkChaosResolver {
	return &podNetworkChaosResolver{r}
}

// PodSelectorSpec returns generated.PodSelectorSpecResolver implementation.
func (r *Resolver) PodSelectorSpec() generated.PodSelectorSpecResolver {
	return &podSelectorSpecResolver{r}
}

// PodStatus returns generated.PodStatusResolver implementation.
func (r *Resolver) PodStatus() generated.PodStatusResolver { return &podStatusResolver{r} }

// PodStressChaos returns generated.PodStressChaosResolver implementation.
func (r *Resolver) PodStressChaos() generated.PodStressChaosResolver {
	return &podStressChaosResolver{r}
}

// Process returns generated.ProcessResolver implementation.
func (r *Resolver) Process() generated.ProcessResolver { return &processResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// RawIPSet returns generated.RawIPSetResolver implementation.
func (r *Resolver) RawIPSet() generated.RawIPSetResolver { return &rawIPSetResolver{r} }

// RawIptables returns generated.RawIptablesResolver implementation.
func (r *Resolver) RawIptables() generated.RawIptablesResolver { return &rawIptablesResolver{r} }

// RawTrafficControl returns generated.RawTrafficControlResolver implementation.
func (r *Resolver) RawTrafficControl() generated.RawTrafficControlResolver {
	return &rawTrafficControlResolver{r}
}

// Record returns generated.RecordResolver implementation.
func (r *Resolver) Record() generated.RecordResolver { return &recordResolver{r} }

// StressChaos returns generated.StressChaosResolver implementation.
func (r *Resolver) StressChaos() generated.StressChaosResolver { return &stressChaosResolver{r} }

// StressChaosSpec returns generated.StressChaosSpecResolver implementation.
func (r *Resolver) StressChaosSpec() generated.StressChaosSpecResolver {
	return &stressChaosSpecResolver{r}
}

// StressChaosStatus returns generated.StressChaosStatusResolver implementation.
func (r *Resolver) StressChaosStatus() generated.StressChaosStatusResolver {
	return &stressChaosStatusResolver{r}
}

type attrOverrideSpecResolver struct{ *Resolver }
type bandwidthSpecResolver struct{ *Resolver }
type chaosConditionResolver struct{ *Resolver }
type cidrAndPortResolver struct{ *Resolver }
type containerStateRunningResolver struct{ *Resolver }
type containerStateTerminatedResolver struct{ *Resolver }
type experimentStatusResolver struct{ *Resolver }
type hTTPChaosResolver struct{ *Resolver }
type hTTPChaosSpecResolver struct{ *Resolver }
type hTTPChaosStatusResolver struct{ *Resolver }
type iOChaosResolver struct{ *Resolver }
type iOChaosActionResolver struct{ *Resolver }
type iOChaosSpecResolver struct{ *Resolver }
type iOChaosStatusResolver struct{ *Resolver }
type ioFaultResolver struct{ *Resolver }
type loggerResolver struct{ *Resolver }
type mistakeSpecResolver struct{ *Resolver }
type mutablePodResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type namespaceResolver struct{ *Resolver }
type networkChaosResolver struct{ *Resolver }
type ownerReferenceResolver struct{ *Resolver }
type podResolver struct{ *Resolver }
type podConditionResolver struct{ *Resolver }
type podHTTPChaosResolver struct{ *Resolver }
type podHttpChaosReplaceActionsResolver struct{ *Resolver }
type podHttpChaosRuleResolver struct{ *Resolver }
type podHttpChaosSelectorResolver struct{ *Resolver }
type podIOChaosResolver struct{ *Resolver }
type podNetworkChaosResolver struct{ *Resolver }
type podSelectorSpecResolver struct{ *Resolver }
type podStatusResolver struct{ *Resolver }
type podStressChaosResolver struct{ *Resolver }
type processResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type rawIPSetResolver struct{ *Resolver }
type rawIptablesResolver struct{ *Resolver }
type rawTrafficControlResolver struct{ *Resolver }
type recordResolver struct{ *Resolver }
type stressChaosResolver struct{ *Resolver }
type stressChaosSpecResolver struct{ *Resolver }
type stressChaosStatusResolver struct{ *Resolver }
